package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	initializers "github.com/Zenithive/it-crm-backend/Initializers"
	"github.com/Zenithive/it-crm-backend/auth"
	"github.com/Zenithive/it-crm-backend/internal/graphql/generated"
	"github.com/Zenithive/it-crm-backend/models"
	"github.com/Zenithive/it-crm-backend/utils"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*generated.AuthPayload, error) {
	var user models.User
	if err := initializers.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("user not found")
	}
	// Validate password
	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	// Generate JWT token
	token, err := auth.GenerateJWT(&user)
	if err != nil {
		return nil, errors.New("failed to generate token")
	}

	return &generated.AuthPayload{
		Token: token,
		User: &generated.User{
			UserID:   fmt.Sprintf("%d", user.ID),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Role:     user.Role,
			Password: user.Password,
		},
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	if input.Name == "" {
		return nil, fmt.Errorf("name is required")
	}
	if input.Email == "" {
		return nil, fmt.Errorf("email is required")
	}
	if input.Password == "" {
		return nil, fmt.Errorf("password is required")
	}
	if input.Role == "" {
		return nil, fmt.Errorf("role is required")
	}
	if input.Role != "ADMIN" && input.Role != "SALES_EXECUTIVE" && input.Role != "MANAGER" {
		return nil, fmt.Errorf("invalid role")
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if initializers.DB != nil {
		user := models.User{
			ID:       uuid.New(),
			GoogleId: *input.GoogleID,
			Name:     input.Name,
			Email:    input.Email,
			Phone:    *input.Phone,
			Password: string(hashedPassword),
			Role:     string(input.Role),
		}
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %v", err)
		}
		result := initializers.DB.Create(&user)
		if result.Error != nil {
			return nil, result.Error
		}
		return &generated.User{
			UserID:   user.ID.String(),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Password: user.Password,
			Role:     user.Role,
		}, nil
	}
	return nil, fmt.Errorf("database connection is nil")
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input generated.UpdateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error fetching role from JWT: %v", err)
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("%s, unauthorized to update user", role)
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Update the user's fields with the input
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Phone != nil {
		user.Phone = *input.Phone
	}
	if input.Role != nil {
		user.Role = string(*input.Role)
	}
	if user.Role != "ADMIN" && user.Role != "SALES_EXECUTIVE" && user.Role != "MANAGER" {
		return nil, fmt.Errorf("enter a valid role")
	}

	// Save the updated user record in the database
	if err := initializers.DB.Save(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Return the updated user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to delete user")
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("User found: ", user)

	// Delete the user record from the database
	if err := initializers.DB.Delete(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to delete user: %v", err)
	}
	fmt.Println("User deleted: ", user)

	// Return the deleted user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input generated.CreateOrganizationInput) (*generated.Organization, error) {
	// Create new organization model instance
	newOrganization := models.Organization{
		OrganizationName:    input.OrganizationName,
		OrganizationEmail:   input.OrganizationEmail,
		OrganizationWebsite: *input.OrganizationWebsite,
		City:                input.City,
		Country:             input.Country,
		NoOfEmployees:       input.NoOfEmployees,
		AnnualRevenue:       input.AnnualRevenue,
	}

	// Save to database
	if err := initializers.DB.Create(&newOrganization).Error; err != nil {
		log.Printf("Error creating organization: %v", err)
		return nil, fmt.Errorf("internal error: failed to create organization")
	}

	// Return the created organization
	return &generated.Organization{
		OrganizationID:      fmt.Sprintf("%d", newOrganization.ID),
		OrganizationName:    newOrganization.OrganizationName,
		OrganizationEmail:   newOrganization.OrganizationEmail,
		OrganizationWebsite: &newOrganization.OrganizationWebsite,
		City:                newOrganization.City,
		Country:             newOrganization.Country,
		NoOfEmployees:       newOrganization.NoOfEmployees,
		AnnualRevenue:       newOrganization.AnnualRevenue,
	}, nil
}

// UpdateOrganization is the resolver for the updateOrganization field.
func (r *mutationResolver) UpdateOrganization(ctx context.Context, organizationID string, input generated.UpdateOrganizationInput) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: UpdateOrganization - updateOrganization"))
	var organization models.Organization

	// Fetch existing organization using UUID
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("organization not found")
		}
		log.Printf("Error fetching organization: %v", err)
		return nil, err
	}

	// Update fields if provided
	if input.OrganizationName != nil {
		organization.OrganizationName = *input.OrganizationName
	}
	if input.OrganizationEmail != nil {
		organization.OrganizationEmail = *input.OrganizationEmail
	}
	if input.OrganizationWebsite != nil {
		organization.OrganizationWebsite = *input.OrganizationWebsite
	}
	if input.City != nil {
		organization.City = *input.City
	}
	if input.Country != nil {
		organization.Country = *input.Country
	}
	if input.NoOfEmployees != nil {
		organization.NoOfEmployees = *input.NoOfEmployees
	}
	if input.AnnualRevenue != nil {
		organization.AnnualRevenue = *input.AnnualRevenue
	}

	// Save changes
	if err := initializers.DB.Save(&organization).Error; err != nil {
		return nil, fmt.Errorf("failed to update organization: %w", err)
	}

	// Return updated organization
	return &generated.Organization{
		OrganizationID:      organization.ID.String(), // Keep as string (UUID)
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
		NoOfEmployees:       organization.NoOfEmployees,
		AnnualRevenue:       organization.AnnualRevenue,
	}, nil
}

// DeleteOrganization is the resolver for the deleteOrganization field.
func (r *mutationResolver) DeleteOrganization(ctx context.Context, organizationID string) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: DeleteOrganization - deleteOrganization"))
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	// Check if organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", organizationID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("Organization found: ", organization)

	// Delete organization
	if err := initializers.DB.Delete(&organization).Error; err != nil {
		return nil, fmt.Errorf("failed to delete organization: %w", err)
	}

	return &generated.Organization{
		OrganizationID:      organization.ID.String(), // Keep as string (UUID)
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
	}, nil
}

// CreateCampaign is the resolver for the createCampaign field.
func (r *mutationResolver) CreateCampaign(ctx context.Context, input generated.CreateCampaignInput) (*generated.Campaign, error) {
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create campaign")
	}
	// Create new campaign
	newCampaign := models.Campaign{
		ID:               uuid.New(),
		CampaignName:     input.CampaignName,
		CampaignCountry:  input.CampaignCountry,
		CampaignRegion:   input.CampaignRegion,
		IndustryTargeted: input.IndustryTargeted,
	}
	if err := initializers.DB.Create(&newCampaign).Error; err != nil {
		log.Printf("Error creating campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to create campaign")
	}
	return &generated.Campaign{
		CampaignID:       newCampaign.ID.String(),
		CampaignName:     newCampaign.CampaignName,
		CampaignCountry:  newCampaign.CampaignCountry,
		CampaignRegion:   newCampaign.CampaignRegion,
		IndustryTargeted: newCampaign.IndustryTargeted,
	}, nil
}

// AddUserToCampaign is the resolver for the addUserToCampaign field.
func (r *mutationResolver) AddUserToCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: AddUserToCampaign - addUserToCampaign"))

	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to add user to campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}
	// Add user to campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Append(&user); err != nil {
		log.Printf("Error adding user to campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to add user to campaign")
	}
	return &generated.Campaign{
		CampaignID:       campaign.ID.String(),
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: user.ID.String(),
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// RemoveUserFromCampaign is the resolver for the removeUserFromCampaign field.
func (r *mutationResolver) RemoveUserFromCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserFromCampaign - removeUserFromCampaign"))
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to remove user from campaign")
	}

	// Check if user is part of the campaign
	var exists bool
	err = initializers.DB.Raw(
		"SELECT EXISTS(SELECT 1 FROM campaign_users WHERE user_id = ? AND campaign_id = ?)", userID, campaignID,
	).Scan(&exists).Error

	if err != nil {
		log.Printf("Error checking user in campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to check user in campaign")
	}

	if !exists {
		return nil, fmt.Errorf("user is not part of this campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}

	// Remove user from campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Delete(&user); err != nil {
		log.Printf("Error removing user from campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to remove user from campaign")

	}
	return &generated.Campaign{
		CampaignID:       campaignID,
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: userID,
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// CreateLead is the resolver for the createLead field.
func (r *mutationResolver) CreateLead(ctx context.Context, input generated.CreateLeadInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	var createdByUser models.User
	if err := initializers.DB.First(&createdByUser, "id = ?", parsedUserID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("created by user not found")
		}
		return nil, err
	}
	parsedLeadAssignedToID, err := uuid.Parse(input.LeadAssignedTo)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadAssignedToID: %v", err)
	}
	parsedOrganizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("invalid OrganizationID: %v", err)
	}
	parsedCampaignID, err := uuid.Parse(input.CampaignID)
	if err != nil {
		return nil, fmt.Errorf("invalid CampaignID: %v", err)
	}
	layout := "2006-01-02"
	parsedDate, err := time.Parse(layout, input.InitialContactDate)
	if err != nil {
		fmt.Println("Error parsing date:", err)
		return nil, err
	}
	fmt.Println("Parsed date:", parsedDate)

	lead := models.Lead{
		ID:                 uuid.New(),
		FirstName:          input.FirstName,
		LastName:           input.LastName,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: parsedDate,
		LeadCreatedBy:      parsedUserID,
		LeadAssignedTo:     parsedLeadAssignedToID,
		LeadStage:          input.LeadStage.String(),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     parsedOrganizationID,
		CampaignID:         parsedCampaignID,
	}

	// Save lead to DB
	if err := initializers.DB.Create(&lead).Error; err != nil {
		return nil, err
	}

	return &generated.Lead{
		LeadID:             lead.ID.String(),
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: input.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
			Name:   createdByUser.Name,
			Email:  createdByUser.Email,
			Phone:  createdByUser.Phone,
		},
		LeadAssignedTo: &generated.User{
			UserID: assignedToUser.ID.String(),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
			Phone:  assignedToUser.Phone,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:      fmt.Sprintf("%d", organization.ID),
			OrganizationName:    organization.OrganizationName,
			OrganizationEmail:   organization.OrganizationEmail,
			OrganizationWebsite: &organization.OrganizationWebsite,
		},

		Campaign: &generated.Campaign{
			CampaignID:      fmt.Sprintf("%d", campaign.ID),
			CampaignName:    campaign.CampaignName,
			CampaignCountry: campaign.CampaignCountry,
			CampaignRegion:  campaign.CampaignRegion,
		},
	}, nil
}

// UpdateLead is the resolver for the updateLead field.
func (r *mutationResolver) UpdateLead(ctx context.Context, leadID string, input generated.UpdateLeadInput) (*generated.Lead, error) {
	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}

	// Check if LeadStage is updated to "WON" from a different value
	isWon := input.LeadStage.String() == "CLOSED_WON" && lead.LeadStage != "CLOSED_WON"

	// Update Lead Details
	if err := initializers.DB.Model(&lead).Updates(models.Lead{
		FirstName:  *input.FirstName,
		LastName:   *input.LastName,
		Email:      input.Email,
		LinkedIn:   *input.LinkedIn,
		Country:    *input.Country,
		Phone:      *input.Phone,
		LeadSource: input.LeadSource,
		// InitialContactDate: input.InitialContactDate,
		// LeadAssignedTo: input.LeadAssignedTo,
		// LeadStage:      input.LeadStage.String(),
		// LeadNotes:      input.LeadNotes,
		// LeadPriority:   input.LeadPriority.String(),
		// OrganizationID: input.OrganizationID,
		// CampaignID:     input.CampaignID,
	}).Error; err != nil {
		return nil, err
	}

	// If LeadStage is updated to "WON" and no existing deal, create a new deal
	if isWon {
		existingDeal := models.Deals{}
		if err := initializers.DB.Where("lead_id = ?", leadID).First(&existingDeal).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				// Create a new Deal only if it does not exist
				newDeal := models.Deals{
					// LeadID:        leadID,
					DealName:      fmt.Sprintf("Deal for %s %s", lead.FirstName, lead.LastName),
					DealAmount:    "0", // Default, can be updated later
					DealStartDate: time.Now(),
					DealEndDate:   time.Now().AddDate(0, 6, 0), // Example: 6 months duration
					DealStatus:    "Active",
				}
				if err := initializers.DB.Create(&newDeal).Error; err != nil {
					log.Printf("Error creating deal for lead %s: %v", leadID, err)
					return nil, fmt.Errorf("internal error: failed to create deal")
				}
			}
		}
	}

	return &generated.Lead{
		LeadID:     leadID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		Email:      lead.Email,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// InitialContactDate: lead.InitialContactDate,
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", lead.Assignee.ID),
			Name:   lead.Assignee.Name,
			Email:  lead.Assignee.Email,
			Phone:  lead.Assignee.Phone,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			// OrganizationID:   lead.OrganizationID,
			OrganizationName: lead.Organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			// CampaignID: lead.CampaignID,
		},
	}, nil
}

// DeleteLead is the resolver for the deleteLead field.
func (r *mutationResolver) DeleteLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: DeleteLead - deleteLead"))

	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&lead).Error; err != nil {
		return nil, err
	}
	return &generated.Lead{
		// LeadID:    lead.LeadID,
		FirstName: lead.FirstName,
		LastName:  lead.LastName,
		Email:     lead.Email,
		LinkedIn:  lead.LinkedIn,
		Country:   lead.Country,
	}, nil
}

// CreateLeadWithActivity is the resolver for the createLeadWithActivity field.
func (r *mutationResolver) CreateLeadWithActivity(ctx context.Context, input generated.CreateLeadWithActivityInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	var createdByUser models.User
	if err := initializers.DB.First(&createdByUser, "id = ?", parsedUserID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("created by user not found")
		}
		return nil, err
	}
	parsedLeadAssignedToID, err := uuid.Parse(input.LeadAssignedTo)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadAssignedToID: %v", err)
	}
	parsedOrganizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("invalid OrganizationID: %v", err)
	}
	parsedCampaignID, err := uuid.Parse(input.CampaignID)
	if err != nil {
		return nil, fmt.Errorf("invalid CampaignID: %v", err)
	}
	layout := "2006-01-02"
	parsedDate, err := time.Parse(layout, input.InitialContactDate)
	if err != nil {
		fmt.Println("Error parsing date:", err)
		return nil, err
	}
	fmt.Println("Parsed date:", parsedDate)

	lead := models.Lead{
		ID:                 uuid.New(),
		FirstName:          input.FirstName,
		LastName:           input.LastName,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: parsedDate,
		LeadCreatedBy:      parsedUserID,
		LeadAssignedTo:     parsedLeadAssignedToID,
		LeadStage:          input.LeadStage.String(),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     parsedOrganizationID,
		CampaignID:         parsedCampaignID,
	}
	parsedDateTime, err := time.Parse(time.RFC3339, input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}
	// Create new activity instance
	newActivity := models.Activity{
		ID:                   uuid.New(),
		LeadID:               lead.ID,
		ActivityType:         input.ActivityType,
		DateTime:             parsedDateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}

	// Use a transaction to ensure both Lead and Activity are created successfully
	err = initializers.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&lead).Error; err != nil {
			log.Printf("Error creating lead: %v", err)
			return fmt.Errorf("internal error: failed to create lead")
		}

		if err := tx.Create(&newActivity).Error; err != nil {
			log.Printf("Error creating activity: %v", err)
			return fmt.Errorf("internal error: failed to create activity")
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Return the created lead and its associated activity
	return &generated.Lead{
		LeadID:             lead.ID.String(),
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: lead.InitialContactDate.Format("2006-01-02"),
		LeadCreatedBy: &generated.User{
			UserID: createdByUser.ID.String(),
			Name:   createdByUser.Name,
			Email:  createdByUser.Email,
		},
		LeadAssignedTo: &generated.User{
			UserID: assignedToUser.ID.String(),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:   organization.ID.String(),
			OrganizationName: organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			CampaignID:   campaign.ID.String(),
			CampaignName: campaign.CampaignName,
		},
		Activities: []*generated.Activity{
			{
				ActivityID:           newActivity.ID.String(),
				LeadID:               newActivity.ID.String(),
				ActivityType:         newActivity.ActivityType,
				DateTime:             newActivity.DateTime.Format(time.RFC3339),
				CommunicationChannel: newActivity.CommunicationChannel,
				ContentNotes:         newActivity.ContentNotes,
				ParticipantDetails:   newActivity.ParticipantDetails,
				FollowUpActions:      newActivity.FollowUpActions,
			},
		},
	}, nil
}

// CreateDeal is the resolver for the createDeal field.
func (r *mutationResolver) CreateDeal(ctx context.Context, input generated.CreateDealInput) (*generated.Deal, error) {
	// panic(fmt.Errorf("not implemented: CreateDeal - createDeal"))

	// Create new deal
	newDeal := models.Deals{
		// LeadID:     input.LeadID,
		DealName:   input.DealName,
		DealAmount: input.DealAmount,
		// DealStartDate: input.DealStartDate,
		// DealEndDate:   input.DealEndDate,
		DealStatus: input.DealStatus.String(),
	}
	if err := initializers.DB.Create(&newDeal).Error; err != nil {
		log.Printf("Error creating deal: %v", err)
		return nil, fmt.Errorf("internal error: failed to create deal")
	}
	return &generated.Deal{
		DealID: fmt.Sprintf("%d", newDeal.ID),
		// LeadID:     newDeal.LeadID,
		DealName:   newDeal.DealName,
		DealAmount: newDeal.DealAmount,
		DealStatus: newDeal.DealStatus,
	}, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input generated.CreateActivityInput) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: CreateActivity - createActivity"))
	parsedLeadID, err := uuid.Parse(input.LeadID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	parsedDateTime, err := time.Parse(time.RFC3339, input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}

	// Create new activity
	newActivity := models.Activity{
		ID:                   uuid.New(),
		LeadID:               parsedLeadID,
		ActivityType:         input.ActivityType,
		DateTime:             parsedDateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}
	var lead models.Lead
	if err := initializers.DB.First(&lead, "id = ?", parsedLeadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("lead with ID %s does not exist", input.LeadID)
		}
		return nil, fmt.Errorf("error checking lead existence: %v", err)
	}

	if err := initializers.DB.Create(&newActivity).Error; err != nil {
		log.Printf("Error creating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to create activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           newActivity.ID.String(),
		LeadID:               newActivity.LeadID.String(),
		ActivityType:         newActivity.ActivityType,
		DateTime:             newActivity.DateTime.Format(time.RFC3339),
		CommunicationChannel: newActivity.CommunicationChannel,
		ContentNotes:         newActivity.ContentNotes,
		ParticipantDetails:   newActivity.ParticipantDetails,
		FollowUpActions:      newActivity.FollowUpActions,
	}, nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, activityID string, input generated.UpdateActivityInput) (*generated.Activity, error) {
	// Update activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	parsedDateTime, err := time.Parse(time.RFC3339, *input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}
	activity.ActivityType = *input.ActivityType
	activity.DateTime = parsedDateTime
	activity.CommunicationChannel = *input.CommunicationChannel
	activity.ContentNotes = *input.ContentNotes
	activity.ParticipantDetails = *input.ParticipantDetails
	activity.FollowUpActions = *input.FollowUpActions
	if err := initializers.DB.Save(&activity).Error; err != nil {
		log.Printf("Error updating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to update activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ID.String(),
		LeadID:               activity.LeadID.String(),
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime.Format(time.RFC3339),
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, activityID string) (*generated.Activity, error) {
	// Delete activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&activity).Error; err != nil {
		log.Printf("Error deleting activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to delete activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ID.String(),
		LeadID:               activity.LeadID.String(),
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime.Format(time.RFC3339),
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// CreateResourceProfile is the resolver for the createResourceProfile field.
func (r *mutationResolver) CreateResourceProfile(ctx context.Context, input generated.CreateResourceProfileInput) (*generated.ResourceProfile, error) {
	resourceProfile := models.ResourceProfile{
		ID:              uuid.New(),
		Type:            models.ResourceType(input.Type),
		FirstName:       input.FirstName,
		LastName:        input.LastName,
		TotalExperience: input.TotalExperience,
		Status:          models.ResourceStatus(input.Status),
	}

	if input.ContactInformation != "" {
		resourceProfile.ContactInformation = []byte(input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}

	if input.VendorID != nil {
		vendorID, err := uuid.Parse(*input.VendorID)
		if err != nil {
			return nil, fmt.Errorf("invalid vendor ID: %w", err)
		}
		resourceProfile.VendorID = vendorID
	}
	// Handle skills with experience years
	var resourceSkills []models.ResourceSkill
	for _, skillInput := range input.SkillInputs {
		skillID, err := uuid.Parse(skillInput.SkillID)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID: %w", err)
		}
		resourceSkills = append(resourceSkills, models.ResourceSkill{
			ResourceProfileID: resourceProfile.ID,
			SkillID:           skillID,
			ExperienceYears:   skillInput.ExperienceYears,
		})
	}

	// Save ResourceProfile and ResourceSkills in a transaction
	tx := initializers.DB.Begin()

	if err := tx.Create(&resourceProfile).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf("failed to create resource profile: %w", err)
	}

	if len(resourceSkills) > 0 {
		if err := tx.Create(&resourceSkills).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("failed to associate skills: %w", err)
		}
	}

	tx.Commit()

	// Fetch the created resource profile along with associated skills
	var fetchedProfile models.ResourceProfile
	if err := initializers.DB.
		Preload("ResourceSkills").
		Preload("ResourceSkills.Skill").
		First(&fetchedProfile, "id = ?", resourceProfile.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch resource profile: %w", err)
	}

	// Convert ResourceSkills for GraphQL response
	resourceSkillsGraphQL := utils.ConvertResourceSkills(fetchedProfile.ResourceSkills)

	// Return GraphQL response
	return &generated.ResourceProfile{
		ResourceProfileID:  resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		VendorID:           resourceProfile.VendorID.String(),
		ResourceSkills:     resourceSkillsGraphQL,
	}, nil
}

// UpdateResourceProfile is the resolver for the updateResourceProfile field.
func (r *mutationResolver) UpdateResourceProfile(ctx context.Context, resourceProfileID string, input generated.UpdateResourceProfileInput) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: UpdateResourceProfile - updateResourceProfile")) //
	// resourceProfileID, err := uuid.Parse(id)
	// if err != nil {
	// 	return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	// }

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	// Update fields using pointers to distinguish between not provided and zero values
	if input.Type != nil {
		resourceProfile.Type = models.ResourceType(*input.Type)
	}
	if input.FirstName != nil {
		resourceProfile.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		resourceProfile.LastName = *input.LastName
	}
	if input.TotalExperience != nil {
		resourceProfile.TotalExperience = *input.TotalExperience
	}
	if input.ContactInformation != nil {
		resourceProfile.ContactInformation = []byte(*input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	if input.Status != nil {
		resourceProfile.Status = models.ResourceStatus(*input.Status)
	}
	// if input.VendorID != nil && *input.VendorID != "" {
	// 	vendorID, err := uuid.Parse(*input.VendorID)
	// 	if err != nil {
	// 		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	// 	}
	// 	resourceProfile.VendorID = &vendorID
	// }
	// Convert string IDs to uint
	skillIDs := make([]uint, len(input.SkillIDs))
	for i, idStr := range input.SkillIDs {
		id, err := strconv.ParseUint(idStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID %s: %w", idStr, err)
		}
		skillIDs[i] = uint(id)
	}

	if len(skillIDs) > 0 {
		skills, err := utils.FetchSkills(skillIDs)
		if err != nil {
			return nil, err
		}
		if err := initializers.DB.Model(&resourceProfile).Association("Skills").Replace(skills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to update resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),

		// Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// DeleteResourceProfile is the resolver for the deleteResourceProfile field.
func (r *mutationResolver) DeleteResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: DeleteResourceProfile - deleteResourceProfile"))
	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	if err := initializers.DB.Delete(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to delete resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),
		// Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input generated.CreateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: CreateVendor - createVendor"))
	vendor := models.Vendor{
		CompanyName:  input.CompanyName,
		Status:       models.VendorStatus(input.Status),       // Enum conversion
		PaymentTerms: models.PaymentTerms(input.PaymentTerms), // Enum conversion
		Address:      input.Address,
	}

	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many)
	if len(input.SkillIDs) > 0 {
		var skills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			// skillID, err := uuid.Parse(skillIDStr)
			// if err != nil {
			// 	return nil, fmt.Errorf("invalid skill ID: %w", err)
			// }
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillIDStr).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			skills = append(skills, skill)
		}
		vendor.Skills = skills
	}

	if err := initializers.DB.Create(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to create vendor: %w", err)
	}
	return &generated.Vendor{
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, vendorID string, input generated.UpdateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: UpdateVendor - updateVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	if input.CompanyName != nil {
		vendor.CompanyName = *input.CompanyName
	}
	if input.Status != nil {
		vendor.Status = models.VendorStatus(*input.Status)
	}
	if input.PaymentTerms != nil {
		vendor.PaymentTerms = models.PaymentTerms(*input.PaymentTerms)
	}
	if input.Address != nil {
		vendor.Address = *input.Address
	}
	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many) - Replace existing skills.
	if input.SkillIDs != nil {
		var newSkills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			skillID, err := uuid.Parse(skillIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid skill ID: %w", err)
			}
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillID).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			newSkills = append(newSkills, skill)
		}
		if err := initializers.DB.Model(&vendor).Association("Skills").Replace(newSkills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to update vendor: %w", err)
	}
	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// DeleteVendor is the resolver for the deleteVendor field.
func (r *mutationResolver) DeleteVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: DeleteVendor - deleteVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", vendor.ID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	// GORM's soft delete.  Use Unscoped() to permanently delete (if needed).
	if err := initializers.DB.Delete(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to delete vendor: %w", err)
	}

	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input generated.CreateTaskInput) (*generated.Task, error) {
	// panic(fmt.Errorf("not implemented: CreateTask - createTask"))
	// Create the task
	jwtClaims, _ := auth.GetUserFromJWT(ctx)

	userID, okid := jwtClaims["user_id"].(string)
	name, _ := jwtClaims["name"].(string)
	fmt.Println("Name: ", name)
	fmt.Println("User ID: ", userID)
	if !okid {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}
	task := models.Task{
		ID:          uuid.New(),
		UserID:      parsedUserID, // Assuming UserID is passed in the input
		Title:       input.Title,
		Description: *input.Description,
		Status:      models.TaskStatus(input.Status),
		Priority:    models.TaskPriority(input.Priority),
		DueDate: func() *time.Time {
			if input.DueDate != "" {
				parsedTime, err := time.Parse(time.RFC3339, input.DueDate)
				if err == nil {
					return &parsedTime
				}
			}
			return nil
		}(),
	}

	// Save task to the database
	if err := initializers.DB.Create(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to create task: %w", err)
	}

	// Return created task
	return &generated.Task{
		TaskID: task.ID.String(),
		// UserID:   task.UserID,
		Title:       task.Title,
		Status:      generated.TaskStatus(task.Status),
		Priority:    generated.TaskPriority(task.Priority),
		Description: &task.Description,
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
		User: &generated.User{
			UserID: userID,
		},
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, taskID string, input generated.UpdateTaskInput) (*generated.Task, error) {
	// Find the task by taskID
	var task models.Task
	if err := initializers.DB.First(&task, "id = ?", taskID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("task with id %s not found", taskID)
		}
		return nil, fmt.Errorf("failed to find task: %w", err)
	}

	// Update task fields based on the input
	if input.Title != nil {
		task.Title = *input.Title
	}
	if input.Description != nil {
		task.Description = *input.Description
	}
	if input.Status != nil {
		task.Status = models.TaskStatus(*input.Status)
	}
	if input.Priority != nil {
		task.Priority = models.TaskPriority(*input.Priority)
	}
	if input.DueDate != nil {
		parsedDueDate, err := time.Parse(time.RFC3339, *input.DueDate)
		if err != nil {
			return nil, fmt.Errorf("invalid due date format: %v", err)
		}
		task.DueDate = &parsedDueDate
	}

	// task.UpdatedAt = time.Now().String() // Set updated timestamp

	// Save the updated task
	if err := initializers.DB.Save(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to update task: %w", err)
	}

	// Return updated task
	return &generated.Task{
		TaskID: task.ID.String(),
		// UserID:    task.UserID,
		Title:    task.Title,
		Status:   generated.TaskStatus(task.Status),
		Priority: generated.TaskPriority(task.Priority),
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
	}, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, taskID string) (*generated.Task, error) {
	var task models.Task
	if err := initializers.DB.First(&task, "id = ?", taskID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("task with id %s not found", taskID)
		}
		return nil, fmt.Errorf("failed to find task: %w", err)
	}

	// Delete the task
	if err := initializers.DB.Delete(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to delete task: %w", err)
	}

	// Return deleted task
	return &generated.Task{
		TaskID: task.ID.String(),
		User: &generated.User{
			UserID: task.UserID.String(),
		},
		Title:    task.Title,
		Status:   generated.TaskStatus(task.Status),
		Priority: generated.TaskPriority(task.Priority),
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
	}, nil
}

// CreateCaseStudy is the resolver for the createCaseStudy field.
func (r *mutationResolver) CreateCaseStudy(ctx context.Context, input generated.CreateCaseStudyInput) (*generated.CaseStudy, error) {
	// Ensure database connection is initialized
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	if input.ProjectName == "" || input.ClientName == "" {
		return nil, fmt.Errorf("project name and client name are required")
	}

	// Create a new case study instance
	caseStudy := models.CaseStudy{
		ID:              uuid.New(), // Ensure UUID is generated if using UUID as the primary key
		ProjectName:     input.ProjectName,
		ClientName:      input.ClientName,
		TechStack:       input.TechStack,
		ProjectDuration: input.ProjectDuration,
		KeyOutcomes:     input.KeyOutcomes,
		IndustryTarget:  input.IndustryTarget,
		Tags:            input.Tags,
		Document:        input.Document,
	}

	// Insert into the database
	if err := initializers.DB.Create(&caseStudy).Error; err != nil {
		return nil, fmt.Errorf("failed to create case study: %v", err)
	}

	// Convert to GraphQL response type
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(), // Ensure consistent UUID usage
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// UpdateCaseStudy is the resolver for the updateCaseStudy field.
func (r *mutationResolver) UpdateCaseStudy(ctx context.Context, caseStudyID string, input generated.UpdateCaseStudyInput) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: UpdateCaseStudy - updateCaseStudy"))
	var caseStudy models.CaseStudy

	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, fmt.Errorf("case study with ID %s not found", caseStudyID) // Case study not found
	}

	if input.ProjectName != "" {
		caseStudy.ProjectName = input.ProjectName
	}
	if input.ClientName != "" {
		caseStudy.ClientName = input.ClientName
	}
	if input.TechStack != "" {
		caseStudy.TechStack = input.TechStack
	}
	if input.ProjectDuration != "" {
		caseStudy.ProjectDuration = input.ProjectDuration
	}
	if input.KeyOutcomes != "" {
		caseStudy.KeyOutcomes = input.KeyOutcomes
	}
	if input.IndustryTarget != "" {
		caseStudy.IndustryTarget = input.IndustryTarget
	}
	if input.Tags != "" {
		caseStudy.Tags = input.Tags
	}
	if input.Document != "" {
		caseStudy.Document = input.Document
	}

	if err := initializers.DB.Save(&caseStudy).Error; err != nil {
		return nil, err
	}

	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// DeleteCaseStudy is the resolver for the deleteCaseStudy field.
func (r *mutationResolver) DeleteCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: DeleteCaseStudy - deleteCaseStudy"))
	var caseStudy models.CaseStudy
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, err // Case study not found
	}
	if err := initializers.DB.Delete(&caseStudy).Error; err != nil {
		return nil, err
	}
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, filter *generated.UserFilter, pagination *generated.PaginationInput, sort *generated.UserSortInput) (*generated.UserPage, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to get user")
	}

	var users []models.User
	query := initializers.DB.Model(&models.User{}).
		Joins("LEFT JOIN campaign_users ON users.id = campaign_users.user_id").
		Joins("LEFT JOIN campaigns ON campaign_users.campaign_id = campaigns.id").
		Preload("Campaigns")

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("users.name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("users.email ILIKE ?", "%"+*filter.Email+"%")
		}
		if filter.Role != nil && *filter.Role != "" {
			query = query.Where("users.role = ?", *filter.Role)
		}
		if filter.Search != nil && *filter.Search != "" {
			query = query.Where("users.name ILIKE ? OR users.email ILIKE ?", "%"+*filter.Search+"%", "%"+*filter.Search+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.UserSortFieldName:
			query = query.Order("users.name " + order)
		case generated.UserSortFieldEmail:
			query = query.Order("users.email " + order)
		case generated.UserSortFieldRole:
			query = query.Order("users.role " + order)
		case generated.UserSortFieldCreatedAt:
			query = query.Order("users.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := int((pagination.Page - 1) * pagination.PageSize)
		query = query.Offset(offset).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&users).Error; err != nil {
		log.Printf("Error fetching users: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch users")
	}

	// Map to GraphQL response type
	var result []*generated.User
	for _, c := range users {
		var campaigns []*generated.Campaign
		for _, u := range c.Campaigns {
			campaigns = append(campaigns, &generated.Campaign{
				CampaignID:       u.ID.String(),
				CampaignName:     u.CampaignName,
				CampaignCountry:  u.CampaignCountry,
				CampaignRegion:   u.CampaignRegion,
				IndustryTargeted: u.IndustryTargeted,
			})
		}
		result = append(result, &generated.User{
			UserID:    c.ID.String(),
			GoogleID:  &c.GoogleId,
			Name:      c.Name,
			Email:     c.Email,
			Phone:     c.Phone,
			Role:      c.Role,
			Password:  c.Password,
			Campaigns: campaigns,
		})
	}

	return &generated.UserPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	// Find the user by ID and preload campaigns
	var user models.User
	if err := initializers.DB.Preload("Campaigns").First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Map campaigns
	var campaigns []*generated.Campaign
	for _, c := range user.Campaigns {
		campaigns = append(campaigns, &generated.Campaign{
			CampaignID:       c.ID.String(),
			CampaignName:     c.CampaignName,
			CampaignCountry:  c.CampaignCountry,
			CampaignRegion:   c.CampaignRegion,
			IndustryTargeted: c.IndustryTargeted,
		})
	}

	// Map the user to the GraphQL response type
	return &generated.User{
		UserID:    user.ID.String(),
		GoogleID:  &user.GoogleId,
		Name:      user.Name,
		Email:     user.Email,
		Phone:     user.Phone,
		Role:      user.Role,
		Password:  user.Password,
		Campaigns: campaigns, // Include campaigns in response
	}, nil
}

// GetCampaigns is the resolver for the getCampaigns field.
func (r *queryResolver) GetCampaigns(ctx context.Context, filter *generated.CampaignFilter, pagination *generated.PaginationInput, sort *generated.CampaignSortInput) (*generated.CampaignPage, error) {
	var campaigns []models.Campaign

	// Preload Users so that each Campaign comes with its associated users.
	query := initializers.DB.Model(&models.Campaign{}).Preload("Users")

	// --- Apply Filters ---
	if filter != nil {
		if filter.CampaignName != nil && *filter.CampaignName != "" {
			query = query.Where("campaigns.campaign_name ILIKE ?", "%"+*filter.CampaignName+"%")
		}
		if filter.CampaignCountry != nil && *filter.CampaignCountry != "" {
			query = query.Where("campaigns.campaign_country = ?", *filter.CampaignCountry)
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.CampaignSortFieldCampaignName:
			query = query.Order("campaigns.campaign_name " + order)
		case generated.CampaignSortFieldCreatedAt:
			query = query.Order("campaigns.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&campaigns).Error; err != nil {
		log.Printf("Error fetching campaigns: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch campaigns")
	}

	// Map the campaigns to your GraphQL type, including the associated users.
	var result []*generated.Campaign
	for _, c := range campaigns {
		// Map associated users for each campaign.
		var users []*generated.User
		for _, u := range c.Users {
			users = append(users, &generated.User{
				UserID:   u.ID.String(),
				GoogleID: &u.GoogleId,
				Name:     u.Name,
				Email:    u.Email,
				Role:     u.Role,
				Phone:    u.Phone,
				// You can map additional fields as needed.
			})
		}

		result = append(result, &generated.Campaign{
			CampaignID:      c.ID.String(),
			CampaignName:    c.CampaignName,
			CampaignCountry: c.CampaignCountry,
			// Map additional campaign fields if needed.
			Users: users, // This field should be defined in your GraphQL Campaign type.
		})
	}

	return &generated.CampaignPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetCampaign is the resolver for the getCampaign field.
func (r *queryResolver) GetCampaign(ctx context.Context, campaignID string) (*generated.Campaign, error) {
	// Retrieve the campaign with the given ID, preloading the associated Users.
	var campaign models.Campaign
	if err := initializers.DB.
		Preload("Users").
		Where("id = ?", campaignID).
		First(&campaign).Error; err != nil {
		log.Printf("Error fetching campaign %s: %v", campaignID, err)
		return nil, fmt.Errorf("internal error: failed to fetch campaign")
	}

	// Map the associated users to the GraphQL type.
	var users []*generated.User
	for _, u := range campaign.Users {
		users = append(users, &generated.User{
			UserID:   u.ID.String(),
			GoogleID: &u.GoogleId,
			Name:     u.Name,
			Email:    u.Email,
			Role:     u.Role,
			Phone:    u.Phone,
			// Map any additional user fields as needed.
		})
	}

	// Map the campaign to the GraphQL type, including the nested users.
	result := &generated.Campaign{
		CampaignID:      campaign.ID.String(),
		CampaignName:    campaign.CampaignName,
		CampaignCountry: campaign.CampaignCountry,
		// Include any additional campaign fields as needed.
		Users: users,
	}

	return result, nil
}

// GetLeads is the resolver for the getLeads field.
func (r *queryResolver) GetLeads(ctx context.Context, filter *generated.LeadFilter, pagination *generated.PaginationInput, sort *generated.LeadSortInput) (*generated.LeadPage, error) {
	// panic(fmt.Errorf("not implemented: GetLeads - getLeads"))
	log.Println("GetAllLeads called")

	var leads []models.Lead
	query := initializers.DB.Model(&models.Lead{})
	query = query.
		Preload("Creator").
		Preload("Assignee").
		Preload("Organization").
		Preload("Campaign").
		Preload("Activities")

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("leads.first_name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("leads.email ILIKE ?", "%"+*filter.Email+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.LeadSortFieldFirstName:
			query = query.Order("leads.first_name " + order)
		case generated.LeadSortFieldLastName:
			query = query.Order("leads.last_name " + order)
		case generated.LeadSortFieldEmail:
			query = query.Order("leads.email " + order)
		case generated.LeadSortFieldCreatedAt:
			query = query.Order("leads.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&leads).Error; err != nil {
		log.Printf("Error fetching leads: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch leads")
	}

	// Map to GraphQL response type
	var result []*generated.Lead

	for _, lead := range leads {
		var activities []*generated.Activity
		for _, activity := range lead.Activities {
			activities = append(activities, &generated.Activity{
				ActivityID:           activity.ID.String(),
				LeadID:               activity.LeadID.String(),
				ActivityType:         activity.ActivityType,
				DateTime:             activity.DateTime.Format("2006-01-02"),
				CommunicationChannel: activity.CommunicationChannel,
				ContentNotes:         activity.ContentNotes,
				ParticipantDetails:   activity.ParticipantDetails,
				FollowUpActions:      activity.FollowUpActions,
			})
		}

		// Map Organization
		var organization *generated.Organization
		if lead.OrganizationID != uuid.Nil {
			organization = &generated.Organization{
				OrganizationID:    lead.Organization.ID.String(),
				OrganizationName:  lead.Organization.OrganizationName,
				OrganizationEmail: lead.Organization.OrganizationEmail,
			}
		}

		// Map Campaign
		var campaign *generated.Campaign
		if lead.CampaignID != uuid.Nil {
			campaign = &generated.Campaign{
				CampaignID:       lead.Campaign.ID.String(),
				CampaignName:     lead.Campaign.CampaignName,
				CampaignCountry:  lead.Campaign.CampaignCountry,
				CampaignRegion:   lead.Campaign.CampaignRegion,
				IndustryTargeted: lead.Campaign.IndustryTargeted,
			}
		}

		result = append(result, &generated.Lead{
			LeadID:     lead.ID.String(),
			FirstName:  lead.FirstName,
			LastName:   lead.LastName,
			LinkedIn:   lead.LinkedIn,
			Email:      lead.Email,
			Country:    lead.Country,
			Phone:      lead.Phone,
			LeadSource: lead.LeadSource,
			LeadCreatedBy: &generated.User{
				UserID: lead.LeadCreatedBy.String(),
				Name:   lead.Creator.Name,
				Email:  lead.Creator.Email,
			},
			LeadAssignedTo: &generated.User{
				UserID: lead.LeadAssignedTo.String(),
				Name:   lead.Assignee.Name,
				Email:  lead.Assignee.Email,
			},
			LeadStage:          lead.LeadStage,
			LeadPriority:       lead.LeadPriority,
			LeadNotes:          lead.LeadNotes,
			InitialContactDate: lead.InitialContactDate.Format("2006-01-02"),
			Activities:         activities,
			Organization:       organization,
			Campaign:           campaign,
		})

	}

	return &generated.LeadPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetLead is the resolver for the getLead field.
func (r *queryResolver) GetLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: GetLead - getLead"))
	role, _ := auth.GetUserRoleFromJWT(ctx)
	if role == "" {
		fmt.Println("Role is empty")
		return nil, fmt.Errorf("missing token")
	}

	// Find the lead by ID
	var lead models.Lead
	if err := initializers.DB.Preload("Activities").Preload("Organization").Preload("Campaign").First(&lead, "lead_id = ?", leadID).Error; err != nil {
		return nil, err
	}

	// Map the lead to the GraphQL response type
	var activities []*generated.Activity
	for _, activity := range lead.Activities {
		activities = append(activities, &generated.Activity{
			// ActivityID:           activity.ActivityID,

			// LeadID:       activity.LeadID,
			ActivityType: activity.ActivityType,
			// DateTime:             activity.DateTime,
			CommunicationChannel: activity.CommunicationChannel,
			ContentNotes:         activity.ContentNotes,
			ParticipantDetails:   activity.ParticipantDetails,
		})
	}

	// Map Organization
	var organization *generated.Organization
	// if lead.OrganizationID != "" {
	// 	organization = &generated.Organization{
	// 		OrganizationID:   fmt.Sprintf("%d", lead.Organization.ID),
	// 		OrganizationName: lead.Organization.OrganizationName,
	// 	}
	// }

	// // Map Campaign
	// var campaign *generated.Campaign
	// if lead.CampaignID != "" {
	// 	campaign = &generated.Campaign{
	// 		CampaignID:       fmt.Sprintf("%d", lead.Campaign.ID),
	// 		CampaignName:     lead.Campaign.CampaignName,
	// 		CampaignCountry:  lead.Campaign.CampaignCountry,
	// 		CampaignRegion:   lead.Campaign.CampaignRegion,
	// 		IndustryTargeted: lead.Campaign.IndustryTargeted,
	// 	}
	// }

	// Map the lead to the GraphQL response type
	return &generated.Lead{
		// LeadID:     lead.LeadID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// LeadCreatedBy:      lead.LeadCreatedBy,
		// LeadAssignedTo:     lead.LeadAssignedTo,
		LeadStage:    lead.LeadStage,
		LeadPriority: lead.LeadPriority,
		LeadNotes:    lead.LeadNotes,
		// InitialContactDate: lead.InitialContactDate,
		Activities:   activities,
		Organization: organization,
		// Campaign:     campaign,
	}, nil
}

// GetOrganizations is the resolver for the getOrganizations field.
func (r *queryResolver) GetOrganizations(ctx context.Context, filter *generated.OrganizationFilter, sort *generated.OrganizationSortInput, pagination *generated.PaginationInput) (*generated.OrganizationPage, error) {
	var organizations []models.Organization
	query := initializers.DB.Model(&models.Organization{})

	// Apply filters
	if filter != nil {
		if filter.Search != nil && *filter.Search != "" {
			query = query.Where("organization_name ILIKE ?", "%"+*filter.Search+"%")
		}
		if filter.Country != nil && *filter.Country != "" {
			query = query.Where("country = ?", *filter.Country)
		}
		if filter.MinEmployees != nil {
			query = query.Where("no_of_employees::INTEGER >= ?", *filter.MinEmployees)
		}
		if filter.MaxEmployees != nil {
			query = query.Where("no_of_employees::INTEGER <= ?", *filter.MaxEmployees)
		}
	}

	// Sorting logic
	if sort != nil {
		var sortColumn string
		switch sort.Field {
		case generated.OrganizationSortFieldOrganizationName:
			sortColumn = "organization_name"
		case generated.OrganizationSortFieldCountry:
			sortColumn = "country"
		case generated.OrganizationSortFieldNoOfEmployees:
			sortColumn = "no_of_employees"
		case generated.OrganizationSortFieldAnnualRevenue:
			sortColumn = "annual_revenue"
		}

		if sort.Order == generated.SortOrderDesc {
			sortColumn += " DESC"
		} else {
			sortColumn += " ASC"
		}
		query = query.Order(sortColumn)
	}

	// Get total count before pagination
	var totalCount int64
	query.Count(&totalCount)

	// Pagination logic
	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&organizations).Error; err != nil {
		log.Printf("Error fetching organizations: %v", err)
		return nil, err
	}

	// Convert to GraphQL response type
	var result []*generated.Organization
	for _, org := range organizations {
		result = append(result, &generated.Organization{
			OrganizationID:      org.ID.String(),
			OrganizationName:    org.OrganizationName,
			OrganizationEmail:   org.OrganizationEmail,
			OrganizationWebsite: &org.OrganizationWebsite,
			City:                org.City,
			Country:             org.Country,
			NoOfEmployees:       org.NoOfEmployees,
			AnnualRevenue:       org.AnnualRevenue,
		})
	}

	return &generated.OrganizationPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetOrganization is the resolver for the getOrganization field.
func (r *queryResolver) GetOrganization(ctx context.Context, organizationID string) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: GetOrganization - getOrganization"))
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id=?", organizationID).Error; err != nil {
		return nil, fmt.Errorf("organization not found: %w", err)
	}

	// Convert to GraphQL response type
	return &generated.Organization{
		OrganizationID:      organization.ID.String(),
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
		NoOfEmployees:       organization.NoOfEmployees,
		AnnualRevenue:       organization.AnnualRevenue,
	}, nil
}

// GetResourceProfiles is the resolver for the getResourceProfiles field.
func (r *queryResolver) GetResourceProfiles(ctx context.Context, filter *generated.ResourceProfileFilter, pagination *generated.PaginationInput, sort *generated.ResourceProfileSortInput) (*generated.ResourceProfilePage, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfiles - getResourceProfiles"))
	var resourceProfiles []models.ResourceProfile
	var totalCount int64

	db := initializers.DB.Model(&models.ResourceProfile{})

	// Apply filtering
	if filter != nil {
		if filter.Type != nil {
			db = db.Where("type = ?", *filter.Type)
		}
		if filter.FirstName != nil {
			db = db.Where("first_name ILIKE ?", "%"+*filter.FirstName+"%")
		}
		if filter.LastName != nil {
			db = db.Where("last_name ILIKE ?", "%"+*filter.LastName+"%")
		}
		if filter.TotalExperienceMin != nil {
			db = db.Where("total_experience >= ?", *filter.TotalExperienceMin)
		}
		if filter.TotalExperienceMax != nil {
			db = db.Where("total_experience <= ?", *filter.TotalExperienceMax)
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.VendorID != nil {
			db = db.Where("vendor_id = ?", *filter.VendorID)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where(
				"first_name ILIKE ? OR last_name ILIKE ? OR EXISTS (SELECT 1 FROM vendors WHERE vendors.id = resource_profiles.vendor_id AND vendors.company_name ILIKE ?)",
				searchPattern, searchPattern, searchPattern,
			)
		}
		if len(filter.SkillIDs) > 0 {
			// Join with the resource_skills table and filter by skill IDs
			db = db.Joins("JOIN resource_skills ON resource_skills.resource_profile_id = resource_profiles.id").
				Where("resource_skills.skill_id IN ?", filter.SkillIDs)
		}
	}
	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.ResourceProfileSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.ResourceProfileSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.ResourceProfileSortFieldFirstName:
			db = db.Order("first_name " + sortOrder)
		case generated.ResourceProfileSortFieldLastName:
			db = db.Order("last_name " + sortOrder)
		case generated.ResourceProfileSortFieldTotalExperience:
			db = db.Order("total_experience " + sortOrder)
		case generated.ResourceProfileSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)
	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Preload("Vendor").Find(&resourceProfiles).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve resource profiles: %w", err)
	}

	// Convert to generated type
	generatedProfiles := make([]*generated.ResourceProfile, len(resourceProfiles))
	for i, profile := range resourceProfiles {

		//convert pastProjects
		var generatedPastProjects []*generated.PastProject

		generatedProfiles[i] = &generated.ResourceProfile{
			// ID:                 profile.ID.String(),
			Type:               generated.ResourceType(profile.Type),
			FirstName:          profile.FirstName,
			LastName:           profile.LastName,
			TotalExperience:    profile.TotalExperience,
			Status:             generated.ResourceStatus(profile.Status),
			ContactInformation: string(profile.ContactInformation),
			GoogleDriveLink:    profile.GoogleDriveLink,
			// VendorID: func() string {
			// 	if profile.VendorID == "" {
			// 		return ""
			// 	}
			// 	return profile.VendorID
			// }(),
			Vendor: func() *generated.Vendor { // Handle Vendor conversion
				// if profile.Vendor == nil {
				// 	return nil
				// }
				return &generated.Vendor{
					// ID:          profile.Vendor.ID.String(),
					// CompanyName: profile.Vendor.CompanyName,
					// Status:      generated.VendorStatus(profile.Vendor.Status),
					// ... other Vendor fields ...
					//convert skills
					Skills: []*generated.Skill{},
					//convert contact list
					ContactList: []*generated.Contact{},
					//convert performance ratings
					PerformanceRatings: []*generated.PerformanceRating{},
					//convert resources
					Resources: []*generated.ResourceProfile{},
				}
			}(),
			// Skills:       utils.ConvertSkills(profile.Skills), // Use the helper function
			PastProjects: generatedPastProjects,
		}
	}

	return &generated.ResourceProfilePage{
		Items:      generatedProfiles,
		TotalCount: int32(totalCount),
	}, nil
}

// GetResourceProfile is the resolver for the getResourceProfile field.
func (r *queryResolver) GetResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfile - getResourceProfile"))
	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	//convert pastProjects
	var generatedPastProjects []*generated.PastProject

	return &generated.ResourceProfile{
		// ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),
		Vendor: func() *generated.Vendor { // Handle the nested Vendor conversion
			// if resourceProfile.Vendor == nil {
			// 	return nil
			// }
			return &generated.Vendor{
				// ID:          resourceProfile.Vendor.ID.String(),
				// CompanyName: resourceProfile.Vendor.CompanyName,
				// Status:      generated.VendorStatus(resourceProfile.Vendor.Status),
				// ... other Vendor fields ...
				//convert skills
				Skills: []*generated.Skill{},
				//convert contact list
				ContactList: []*generated.Contact{},
				//convert performance ratings
				PerformanceRatings: []*generated.PerformanceRating{},
				//convert resources
				Resources: []*generated.ResourceProfile{},
			}
		}(),
		// Skills:       utils.ConvertSkills(resourceProfile.Skills), // Convert skills
		PastProjects: generatedPastProjects,
	}, nil
}

// GetVendors is the resolver for the getVendors field.
func (r *queryResolver) GetVendors(ctx context.Context, filter *generated.VendorFilter, pagination *generated.PaginationInput, sort *generated.VendorSortInput) (*generated.VendorPage, error) {
	// panic(fmt.Errorf("not implemented: GetVendors - getVendors"))
	var vendors []models.Vendor
	var totalCount int64

	db := initializers.DB.Model(&models.Vendor{})

	// Apply filtering
	if filter != nil {
		if filter.CompanyName != nil {
			db = db.Where("company_name ILIKE ?", "%"+*filter.CompanyName+"%")
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.PaymentTerms != nil {
			db = db.Where("payment_terms = ?", *filter.PaymentTerms)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where("company_name ILIKE ? OR address ILIKE ?", searchPattern, searchPattern)
		}
		if len(filter.SkillIDs) > 0 {
			db = db.Joins("JOIN vendor_skills ON vendor_skills.vendor_id = vendors.id").
				Where("vendor_skills.skill_id IN ?", filter.SkillIDs)
		}
	}

	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.VendorSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.VendorSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.VendorSortFieldCompanyName:
			db = db.Order("company_name " + sortOrder)
		case generated.VendorSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)

	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Find(&vendors).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve vendors: %w", err)
	}

	// Convert to generated type
	generatedVendors := make([]*generated.Vendor, len(vendors))
	for i, vendor := range vendors {
		//convert skills
		var generatedSkills []*generated.Skill
		//convert contact list
		var generatedContactList []*generated.Contact
		//convert performance ratings
		var generatedPerformanceRatings []*generated.PerformanceRating
		//convert resources
		var generatedResources []*generated.ResourceProfile

		generatedVendors[i] = &generated.Vendor{
			// ID:                 vendor.ID.String(),
			CompanyName:        vendor.CompanyName,
			Status:             generated.VendorStatus(vendor.Status),
			PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
			Address:            vendor.Address,
			GstOrVatDetails:    vendor.GstOrVatDetails,
			Notes:              vendor.Notes,
			Skills:             generatedSkills,
			ContactList:        generatedContactList,
			PerformanceRatings: generatedPerformanceRatings,
			Resources:          generatedResources,
		}
	}

	return &generated.VendorPage{
		Items:      generatedVendors,
		TotalCount: int32(totalCount),
	}, nil
}

// GetVendor is the resolver for the getVendor field.
func (r *queryResolver) GetVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: GetVendor - getVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	//convert skills
	var generatedSkills []*generated.Skill
	//convert contact list
	var generatedContactList []*generated.Contact
	//convert performance ratings
	var generatedPerformanceRatings []*generated.PerformanceRating
	//convert resources
	var generatedResources []*generated.ResourceProfile
	return &generated.Vendor{
		// ID:                 vendor.ID.String(),
		CompanyName:        vendor.CompanyName,
		Status:             generated.VendorStatus(vendor.Status),
		PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
		Address:            vendor.Address,
		GstOrVatDetails:    vendor.GstOrVatDetails,
		Notes:              vendor.Notes,
		Skills:             generatedSkills,
		ContactList:        generatedContactList,
		PerformanceRatings: generatedPerformanceRatings,
		Resources:          generatedResources,
	}, nil
}

// GetTasks is the resolver for the getTasks field.
func (r *queryResolver) GetTasks(ctx context.Context, filter *generated.TaskFilter, pagination *generated.PaginationInput, sort *generated.TaskSortInput) (*generated.TaskPage, error) {
	// panic(fmt.Errorf("not implemented: GetTasks - getTasks"))
	var tasks []models.Task
	query := initializers.DB.Model(&models.Task{})

	// Filtering
	if filter != nil {
		if filter.UserID != nil {
			query = query.Where("user_id = ?", *filter.UserID)
		}
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
		if filter.Priority != nil {
			query = query.Where("priority = ?", *filter.Priority)
		}
		// Remove the due date filter as it does not exist in the TaskFilter type
	}

	// Sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.TaskSortFieldTitle:
			query = query.Order("title " + sortOrder)
		case generated.TaskSortFieldStatus:
			query = query.Order("status " + sortOrder)
		case generated.TaskSortFieldPriority:
			query = query.Order("priority " + sortOrder)
		case generated.TaskSortFieldDueDate:
			query = query.Order("due_date " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		query = query.Order("created_at desc")
	}

	// Pagination
	var totalCount int64
	query.Count(&totalCount)
	if pagination != nil {
		query = query.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&tasks).Error; err != nil {
		return nil, err
	}

	return &generated.TaskPage{
		Items: func() []*generated.Task {
			var gqlTasks []*generated.Task
			for _, task := range tasks {
				gqlTasks = append(gqlTasks, &generated.Task{
					TaskID:   task.ID.String(),
					Title:    task.Title,
					Status:   generated.TaskStatus(task.Status),
					Priority: generated.TaskPriority(task.Priority),
					DueDate:  task.DueDate.Format(time.RFC3339),
				})
			}
			return gqlTasks
		}(),
		TotalCount: int32(totalCount),
	}, nil
}

// GetTasksByUser is the resolver for the getTasksByUser field.
func (r *queryResolver) GetTasksByUser(ctx context.Context, filter *generated.TaskFilter, pagination *generated.PaginationInput, sort *generated.TaskSortInput) (*generated.TaskPage, error) {
	// panic(fmt.Errorf("not implemented: GetTasksByUser - getTasksByUser"))
	var tasks []models.Task

	jwtClaims, ok := auth.GetUserFromJWT(ctx)
	if !ok {
		return nil, fmt.Errorf("no user in jwt returned")
	}
	userID, ok := jwtClaims["user_id"].(string)
	if !ok {
		fmt.Println("UserID not found in token")
	}
	name, ok := jwtClaims["name"].(string)
	if !ok {
		fmt.Println("Name not found in token")
	}
	fmt.Println("User Name:", name)
	query := initializers.DB.Model(&models.Task{}).Where("user_id = ?", userID)
	// Filtering
	if filter != nil {
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
		if filter.Priority != nil {
			query = query.Where("priority = ?", *filter.Priority)
		}
		// Remove the due date filter as it does not exist in the TaskFilter type
	}

	// Sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.TaskSortFieldTitle:
			query = query.Order("title " + sortOrder)
		case generated.TaskSortFieldStatus:
			query = query.Order("status " + sortOrder)
		case generated.TaskSortFieldPriority:
			query = query.Order("priority " + sortOrder)
		case generated.TaskSortFieldDueDate:
			query = query.Order("due_date " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		query = query.Order("created_at desc")
	}

	// Pagination
	var totalCount int64
	query.Count(&totalCount)
	if pagination != nil {
		query = query.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&tasks).Error; err != nil {
		return nil, err
	}

	return &generated.TaskPage{
		Items: func() []*generated.Task {
			var gqlTasks []*generated.Task
			for _, task := range tasks {
				gqlTasks = append(gqlTasks, &generated.Task{
					TaskID:   task.ID.String(),
					Title:    task.Title,
					Status:   generated.TaskStatus(task.Status),
					Priority: generated.TaskPriority(task.Priority),
					DueDate:  task.DueDate.Format(time.RFC3339),
				})
			}
			return gqlTasks
		}(),
		TotalCount: int32(totalCount),
	}, nil
}

// GetTask is the resolver for the getTask field.
func (r *queryResolver) GetTask(ctx context.Context, taskID string) (*generated.Task, error) {
	// panic(fmt.Errorf("not implemented: GetTask - getTask"))
	var task models.Task

	// Convert taskID to UUID
	taskUUID, err := uuid.Parse(taskID)
	if err != nil {
		return nil, fmt.Errorf("invalid task ID format: %w", err)
	}

	// Fetch task from the database
	if err := initializers.DB.Preload("User").Where("id = ?", taskUUID).First(&task).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("task not found")
		}
		return nil, err
	}

	// Convert to GraphQL type
	return &generated.Task{
		TaskID:      task.ID.String(),
		User:        &generated.User{UserID: task.User.ID.String(), Name: task.User.Name, Email: task.User.Email}, // Adjust as needed
		Title:       task.Title,
		Description: &task.Description,
		Status:      generated.TaskStatus(task.Status),
		Priority:    generated.TaskPriority(task.Priority),
		DueDate:     task.DueDate.Format(time.RFC3339),
	}, nil
}

// GetCaseStudies is the resolver for the getCaseStudies field.
func (r *queryResolver) GetCaseStudies(ctx context.Context, filter *generated.CaseStudyFilter, pagination *generated.PaginationInput, sort *generated.CaseStudySortInput) ([]*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: GetCaseStudies - getCaseStudies"))
	var caseStudies []*models.CaseStudy
	db := initializers.DB

	// Apply Filters
	if filter != nil {
		if filter.ProjectName != nil {
			db = db.Where("project_name ILIKE ?", "%"+*filter.ProjectName+"%")
		}
		if filter.ClientName != nil {
			db = db.Where("client_name ILIKE ?", "%"+*filter.ClientName+"%")
		}
		if filter.TechStack != nil {
			db = db.Where("tech_stack ILIKE ?", "%"+*filter.TechStack+"%")
		}
		if filter.IndustryTarget != nil {
			db = db.Where("industry_target ILIKE ?", "%"+*filter.IndustryTarget+"%")
		}
		if filter.Tags != nil {
			db = db.Where("tags ILIKE ?", "%"+*filter.Tags+"%")
		}
		// Apply Search across multiple fields
		if filter.Search != nil {
			searchQuery := "%" + *filter.Search + "%"
			db = db.Where("project_name ILIKE ? OR client_name ILIKE ? OR tech_stack ILIKE ? OR industry_target ILIKE ? OR tags ILIKE ?",
				searchQuery, searchQuery, searchQuery, searchQuery, searchQuery)
		}
	}

	// Apply Sorting
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.CaseStudySortFieldCreatedAt:
			db = db.Order("created_at " + order)
		case generated.CaseStudySortFieldUpdatedAt:
			db = db.Order("updated_at " + order)
		case generated.CaseStudySortFieldTechStack:
			db = db.Order("tech_stack " + order)
		case generated.CaseStudySortFieldIndustryTarget:
			db = db.Order("industry_target " + order)
		}
	}

	// Apply Pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Fetch case studies
	if err := db.Find(&caseStudies).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve case studies: %v", err)
	}

	// Convert to GraphQL type
	var gqlCaseStudies []*generated.CaseStudy
	for _, cs := range caseStudies {
		gqlCaseStudies = append(gqlCaseStudies, &generated.CaseStudy{
			CaseStudyID:     cs.ID.String(),
			ProjectName:     cs.ProjectName,
			ClientName:      cs.ClientName,
			TechStack:       cs.TechStack,
			ProjectDuration: cs.ProjectDuration,
			KeyOutcomes:     cs.KeyOutcomes,
			IndustryTarget:  cs.IndustryTarget,
			Tags:            cs.Tags,
			Document:        cs.Document,
		})
	}

	return gqlCaseStudies, nil
}

// GetCaseStudy is the resolver for the getCaseStudy field.
func (r *queryResolver) GetCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: GetCaseStudy - getCaseStudy"))
	var caseStudy models.CaseStudy
	// Fetch case study by ID from the database
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, fmt.Errorf("case study not found: %v", err)
	}
	// Convert model to GraphQL type
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(), // Ensure correct ID format
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
