package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	initializers "github.com/Zenithive/it-crm-backend/Initializers"
	"github.com/Zenithive/it-crm-backend/auth"
	"github.com/Zenithive/it-crm-backend/internal/graphql/generated"
	"github.com/Zenithive/it-crm-backend/models"
	"github.com/Zenithive/it-crm-backend/utils"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Login is the resolver for the login field.
// Login handles user login.
// It takes an email and password as input parameters.
// It returns an AuthPayload containing the JWT token and the user details.
// If the user is not found or the password is invalid, it returns an error.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*generated.AuthPayload, error) {
	var user models.User
	if err := initializers.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("user not found")
	}

	// Validate password
	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	// Generate JWT token
	accessToken, _, err := auth.GenerateTokens(&user, "Local")
	if err != nil {
		fmt.Println("Token Generation Error:", err) // Print the actual error
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	return &generated.AuthPayload{
		Token: accessToken,
		User: &generated.User{
			UserID:   user.ID.String(),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Role:     user.Role,
			Password: user.Password,
		},
	}, nil
}

// CreateUser is the resolver for the createUser field.
// CreateUser creates a new user in the system.
// It checks for proper authorization, validates input, and stores the new user in the database.
// Parameters:
//   - ctx: The context for the request, used for authorization.
//   - input: A CreateUserInput struct containing the new user's details.
//
// Returns:
//   - A pointer to a generated.User struct containing the created user's information.
//   - An error if the operation fails (e.g., unauthorized access, invalid input, database errors).
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	if input.Name == "" {
		return nil, fmt.Errorf("name is required")
	}
	if input.Email == "" {
		return nil, fmt.Errorf("email is required")
	}
	if input.Password == "" {
		return nil, fmt.Errorf("password is required")
	}
	if input.Role == "" {
		return nil, fmt.Errorf("role is required")
	}
	if input.Role != "ADMIN" && input.Role != "SALES_EXECUTIVE" && input.Role != "MANAGER" {
		return nil, fmt.Errorf("invalid role")
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if initializers.DB != nil {
		user := models.User{
			ID:       uuid.New(),
			GoogleId: *input.GoogleID,
			Name:     input.Name,
			Email:    input.Email,
			Phone:    *input.Phone,
			Password: string(hashedPassword),
			Role:     string(input.Role),
		}
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %v", err)
		}
		result := initializers.DB.Create(&user)
		if result.Error != nil {
			return nil, result.Error
		}
		return &generated.User{
			UserID:   user.ID.String(),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Password: user.Password,
			Role:     user.Role,
		}, nil
	}
	return nil, fmt.Errorf("database connection is nil")
}

// UpdateUser is the resolver for the updateUser field.
// UpdateUser updates an existing user's information in the database.
// It checks for proper authorization and validates the input before updating.
//
// Parameters:
//   - ctx: The context for the request, used for authorization.
//   - userID: A string representing the unique identifier of the user to be updated.
//   - input: A generated.UpdateUserInput struct containing the fields to be updated.
//
// Returns:
//   - A pointer to a generated.User struct containing the updated user information.
//   - An error if the operation fails (e.g., unauthorized access, user not found, invalid input, database errors).
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input generated.UpdateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error fetching role from JWT: %v", err)
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("%s, unauthorized to update user", role)
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Update the user's fields with the input
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Phone != nil {
		user.Phone = *input.Phone
	}
	if input.Role != nil {
		user.Role = string(*input.Role)
	}
	if user.Role != "ADMIN" && user.Role != "SALES_EXECUTIVE" && user.Role != "MANAGER" {
		return nil, fmt.Errorf("enter a valid role")
	}

	// Save the updated user record in the database
	if err := initializers.DB.Save(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Return the updated user
	return &generated.User{
		UserID:   user.ID.String(),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// `DeleteUser` is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to delete user")
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("User found: ", user)

	// Delete the user record from the database
	if err := initializers.DB.Delete(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to delete user: %v", err)
	}
	fmt.Println("User deleted: ", user)

	// Return the deleted user
	return &generated.User{
		UserID:   user.ID.String(),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input generated.CreateOrganizationInput) (*generated.Organization, error) {
	// Create new organization model instance
	newOrganization := models.Organization{
		OrganizationName:    input.OrganizationName,
		OrganizationEmail:   input.OrganizationEmail,
		OrganizationWebsite: *input.OrganizationWebsite,
		City:                input.City,
		Country:             input.Country,
		NoOfEmployees:       input.NoOfEmployees,
		AnnualRevenue:       input.AnnualRevenue,
	}

	// Save to database
	if err := initializers.DB.Create(&newOrganization).Error; err != nil {
		log.Printf("Error creating organization: %v", err)
		return nil, fmt.Errorf("internal error: failed to create organization")
	}

	// Return the created organization
	return &generated.Organization{
		OrganizationID:      newOrganization.ID.String(),
		OrganizationName:    newOrganization.OrganizationName,
		OrganizationEmail:   newOrganization.OrganizationEmail,
		OrganizationWebsite: &newOrganization.OrganizationWebsite,
		City:                newOrganization.City,
		Country:             newOrganization.Country,
		NoOfEmployees:       newOrganization.NoOfEmployees,
		AnnualRevenue:       newOrganization.AnnualRevenue,
	}, nil
}

// UpdateOrganization is the resolver for the updateOrganization field.
func (r *mutationResolver) UpdateOrganization(ctx context.Context, organizationID string, input generated.UpdateOrganizationInput) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: UpdateOrganization - updateOrganization"))
	var organization models.Organization

	// Fetch existing organization using UUID
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("organization not found")
		}
		log.Printf("Error fetching organization: %v", err)
		return nil, err
	}

	// Update fields if provided
	if input.OrganizationName != nil {
		organization.OrganizationName = *input.OrganizationName
	}
	if input.OrganizationEmail != nil {
		organization.OrganizationEmail = *input.OrganizationEmail
	}
	if input.OrganizationWebsite != nil {
		organization.OrganizationWebsite = *input.OrganizationWebsite
	}
	if input.City != nil {
		organization.City = *input.City
	}
	if input.Country != nil {
		organization.Country = *input.Country
	}
	if input.NoOfEmployees != nil {
		organization.NoOfEmployees = *input.NoOfEmployees
	}
	if input.AnnualRevenue != nil {
		organization.AnnualRevenue = *input.AnnualRevenue
	}

	// Save changes
	if err := initializers.DB.Save(&organization).Error; err != nil {
		return nil, fmt.Errorf("failed to update organization: %w", err)
	}

	// Return updated organization
	return &generated.Organization{
		OrganizationID:      organization.ID.String(), // Keep as string (UUID)
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
		NoOfEmployees:       organization.NoOfEmployees,
		AnnualRevenue:       organization.AnnualRevenue,
	}, nil
}

// DeleteOrganization is the resolver for the deleteOrganization field.
func (r *mutationResolver) DeleteOrganization(ctx context.Context, organizationID string) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: DeleteOrganization - deleteOrganization"))
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	// Check if organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", organizationID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("Organization found: ", organization)

	// Delete organization
	if err := initializers.DB.Delete(&organization).Error; err != nil {
		return nil, fmt.Errorf("failed to delete organization: %w", err)
	}

	return &generated.Organization{
		OrganizationID:      organization.ID.String(), // Keep as string (UUID)
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
	}, nil
}

// CreateCampaign is the resolver for the createCampaign field.
func (r *mutationResolver) CreateCampaign(ctx context.Context, input generated.CreateCampaignInput) (*generated.Campaign, error) {
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create campaign")
	}
	// Create new campaign
	newCampaign := models.Campaign{
		ID:               uuid.New(),
		CampaignName:     input.CampaignName,
		CampaignCountry:  input.CampaignCountry,
		CampaignRegion:   input.CampaignRegion,
		IndustryTargeted: input.IndustryTargeted,
	}
	if err := initializers.DB.Create(&newCampaign).Error; err != nil {
		log.Printf("Error creating campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to create campaign")
	}
	return &generated.Campaign{
		CampaignID:       newCampaign.ID.String(),
		CampaignName:     newCampaign.CampaignName,
		CampaignCountry:  newCampaign.CampaignCountry,
		CampaignRegion:   newCampaign.CampaignRegion,
		IndustryTargeted: newCampaign.IndustryTargeted,
	}, nil
}

// AddUserToCampaign is the resolver for the addUserToCampaign field.
func (r *mutationResolver) AddUserToCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: AddUserToCampaign - addUserToCampaign"))

	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to add user to campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}
	// Add user to campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Append(&user); err != nil {
		log.Printf("Error adding user to campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to add user to campaign")
	}
	return &generated.Campaign{
		CampaignID:       campaign.ID.String(),
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: user.ID.String(),
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// RemoveUserFromCampaign is the resolver for the removeUserFromCampaign field.
func (r *mutationResolver) RemoveUserFromCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserFromCampaign - removeUserFromCampaign"))
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to remove user from campaign")
	}

	// Check if user is part of the campaign
	var exists bool
	err = initializers.DB.Raw(
		"SELECT EXISTS(SELECT 1 FROM campaign_users WHERE user_id = ? AND campaign_id = ?)", userID, campaignID,
	).Scan(&exists).Error

	if err != nil {
		log.Printf("Error checking user in campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to check user in campaign")
	}

	if !exists {
		return nil, fmt.Errorf("user is not part of this campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}

	// Remove user from campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Delete(&user); err != nil {
		log.Printf("Error removing user from campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to remove user from campaign")

	}
	return &generated.Campaign{
		CampaignID:       campaignID,
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: userID,
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// UpdateCampaign is the resolver for the updateCampaign field.
func (r *mutationResolver) UpdateCampaign(ctx context.Context, campaignID string, input generated.UpdateCampaignInput) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: UpdateCampaign - updateCampaign"))
	// Find the campaign by ID
	var campaign models.Campaign

	// Fetch existing campaign using UUID
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {

		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("campaign with ID %s not found", campaignID)
		}
		return nil, fmt.Errorf("error retrieving campaign: %w", err)
	}

	// Update campaign fields
	campaign.CampaignName = *input.CampaignName
	campaign.CampaignCountry = *input.CampaignCountry
	campaign.CampaignRegion = *input.CampaignRegion
	campaign.IndustryTargeted = *input.IndustryTargeted
	if err := initializers.DB.Save(&campaign).Error; err != nil {
		return nil, fmt.Errorf("failed to update campaign: %w", err)
	}

	return &generated.Campaign{
		CampaignID:       campaignID,
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
	}, nil
}

// DeleteCampaign is the resolver for the deleteCampaign field.
func (r *mutationResolver) DeleteCampaign(ctx context.Context, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: DeleteCampaign - deleteCampaign"))
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, err
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to delete campaign")
	}
	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("campaign with ID %s not found", campaignID)
		}
		return nil, fmt.Errorf("error retrieving campaign: %w", err)
	}

	// Delete the campaign
	if err := initializers.DB.Delete(&campaign).Error; err != nil {
		return nil, fmt.Errorf("failed to delete campaign: %w", err)
	}
	return &generated.Campaign{
		CampaignID:       campaignID,
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
	}, nil
}

// CreateLead is the resolver for the createLead field.
func (r *mutationResolver) CreateLead(ctx context.Context, input generated.CreateLeadInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	var createdByUser models.User
	if err := initializers.DB.First(&createdByUser, "id = ?", parsedUserID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("created by user not found")
		}
		return nil, err
	}
	parsedLeadAssignedToID, err := uuid.Parse(input.LeadAssignedTo)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadAssignedToID: %v", err)
	}
	parsedOrganizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("invalid OrganizationID: %v", err)
	}
	parsedCampaignID, err := uuid.Parse(input.CampaignID)
	if err != nil {
		return nil, fmt.Errorf("invalid CampaignID: %v", err)
	}
	layout := "2006-01-02"
	parsedDate, err := time.Parse(layout, input.InitialContactDate)
	if err != nil {
		fmt.Println("Error parsing date:", err)
		return nil, err
	}
	fmt.Println("Parsed date:", parsedDate)

	lead := models.Lead{
		ID:                 uuid.New(),
		FirstName:          input.FirstName,
		LastName:           input.LastName,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: parsedDate,
		LeadCreatedBy:      parsedUserID,
		LeadAssignedTo:     parsedLeadAssignedToID,
		LeadStage:          models.LeadStage(input.LeadStage),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     parsedOrganizationID,
		CampaignID:         parsedCampaignID,
	}

	// Save lead to DB
	if err := initializers.DB.Create(&lead).Error; err != nil {
		return nil, err
	}

	return &generated.Lead{
		LeadID:             lead.ID.String(),
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: input.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
			Name:   createdByUser.Name,
			Email:  createdByUser.Email,
			Phone:  createdByUser.Phone,
		},
		LeadAssignedTo: &generated.User{
			UserID: assignedToUser.ID.String(),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
			Phone:  assignedToUser.Phone,
		},
		LeadStage:    string(lead.LeadStage),
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:      fmt.Sprintf("%d", organization.ID),
			OrganizationName:    organization.OrganizationName,
			OrganizationEmail:   organization.OrganizationEmail,
			OrganizationWebsite: &organization.OrganizationWebsite,
		},

		Campaign: &generated.Campaign{
			CampaignID:      fmt.Sprintf("%d", campaign.ID),
			CampaignName:    campaign.CampaignName,
			CampaignCountry: campaign.CampaignCountry,
			CampaignRegion:  campaign.CampaignRegion,
		},
	}, nil
}

// UpdateLead is the resolver for the updateLead field.
func (r *mutationResolver) UpdateLead(ctx context.Context, leadID string, input generated.UpdateLeadInput) (*generated.Lead, error) {
	lead := models.Lead{}
	if err := initializers.DB.
		Preload("Creator").
		Preload("Assignee").
		Preload("Organization").
		Preload("Campaign").
		First(&lead, "id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}
	oldStage := lead.LeadStage

	// Check if LeadStage is being updated
	isStageChanged := string(input.LeadStage) != string(lead.LeadStage)
	// Check if LeadStage is updated to "WON" from a different value
	isWon := input.LeadStage.String() == "CLOSED_WON" && lead.LeadStage != "CLOSED_WON"

	tx := initializers.DB.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Update Lead Details
	if err := tx.Model(&lead).Updates(models.Lead{
		FirstName:  *input.FirstName,
		LastName:   *input.LastName,
		Email:      input.Email,
		LinkedIn:   *input.LinkedIn,
		Country:    *input.Country,
		Phone:      *input.Phone,
		LeadSource: input.LeadSource,
		LeadStage:  models.LeadStage(input.LeadStage), // Ensure lead stage is updated
	}).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	if isStageChanged {
		historyRecord := models.LeadStageHistory{
			LeadID:    lead.ID,
			OldStage:  oldStage,
			NewStage:  models.LeadStage(input.LeadStage.String()),
			ChangedAt: time.Now(),
		}
		if err := tx.Create(&historyRecord).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("failed to record lead stage history: %v", err)
		}
	}

	// If LeadStage is updated to "WON" and no existing deal, create a new deal
	if isWon {
		existingDeal := models.Deal{}
		if err := tx.Where("id = ?", leadID).First(&existingDeal).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				// Create a new Deal only if it does not exist
				newDeal := models.Deal{
					LeadID:        lead.ID, // Ensure LeadID is stored
					DealName:      lead.FirstName + " " + lead.LastName,
					DealAmount:    "0", // Default, can be updated later
					DealStartDate: time.Now(),
					DealEndDate:   time.Now().AddDate(0, 6, 0), // Example: 6 months duration
					DealStatus:    "Active",
				}
				if err := tx.Create(&newDeal).Error; err != nil {
					tx.Rollback()
					log.Printf("Error creating deal for lead %s: %v", leadID, err)
					return nil, fmt.Errorf("internal error: failed to create deal")
				}
			} else {
				tx.Rollback()
				return nil, err
			}
		}
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return nil, fmt.Errorf("transaction commit failed: %v", err)
	}

	return &generated.Lead{
		LeadID:             leadID,
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: lead.InitialContactDate.Format(time.RFC3339),
		LeadCreatedBy: &generated.User{
			UserID: lead.LeadCreatedBy.String(),
			Name:   lead.Creator.Name,
			Email:  lead.Creator.Email,
			Phone:  lead.Creator.Phone,
		},
		LeadAssignedTo: &generated.User{
			UserID: lead.LeadAssignedTo.String(),
			Name:   lead.Assignee.Name,
			Email:  lead.Assignee.Email,
			Phone:  lead.Assignee.Phone,
		},
		LeadStage:    string(lead.LeadStage),
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:      lead.OrganizationID.String(),
			OrganizationName:    lead.Organization.OrganizationName,
			OrganizationWebsite: &lead.Organization.OrganizationWebsite,
		},
		Campaign: &generated.Campaign{
			CampaignID:       lead.CampaignID.String(),
			CampaignName:     lead.Campaign.CampaignName,
			CampaignCountry:  lead.Campaign.CampaignCountry,
			CampaignRegion:   lead.Campaign.CampaignRegion,
			IndustryTargeted: lead.Campaign.IndustryTargeted,
		},
	}, nil
}

// DeleteLead is the resolver for the deleteLead field.
func (r *mutationResolver) DeleteLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: DeleteLead - deleteLead"))

	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&lead).Error; err != nil {
		return nil, err
	}
	return &generated.Lead{
		LeadID:    lead.ID.String(),
		FirstName: lead.FirstName,
		LastName:  lead.LastName,
		Email:     lead.Email,
		LinkedIn:  lead.LinkedIn,
		Country:   lead.Country,
	}, nil
}

// CreateLeadWithActivity is the resolver for the createLeadWithActivity field.
func (r *mutationResolver) CreateLeadWithActivity(ctx context.Context, input generated.CreateLeadWithActivityInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	var createdByUser models.User
	if err := initializers.DB.First(&createdByUser, "id = ?", parsedUserID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("created by user not found")
		}
		return nil, err
	}
	parsedLeadAssignedToID, err := uuid.Parse(input.LeadAssignedTo)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadAssignedToID: %v", err)
	}
	parsedOrganizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, fmt.Errorf("invalid OrganizationID: %v", err)
	}
	parsedCampaignID, err := uuid.Parse(input.CampaignID)
	if err != nil {
		return nil, fmt.Errorf("invalid CampaignID: %v", err)
	}
	layout := "2006-01-02"
	parsedDate, err := time.Parse(layout, input.InitialContactDate)
	if err != nil {
		fmt.Println("Error parsing date:", err)
		return nil, err
	}
	fmt.Println("Parsed date:", parsedDate)

	lead := models.Lead{
		ID:                 uuid.New(),
		FirstName:          input.FirstName,
		LastName:           input.LastName,
		Email:              input.Email,
		LinkedIn:           input.LinkedIn,
		Country:            input.Country,
		Phone:              input.Phone,
		LeadSource:         input.LeadSource,
		InitialContactDate: parsedDate,
		LeadCreatedBy:      parsedUserID,
		LeadAssignedTo:     parsedLeadAssignedToID,
		LeadStage:          models.LeadStage(input.LeadStage),
		LeadNotes:          input.LeadNotes,
		LeadPriority:       input.LeadPriority.String(),
		OrganizationID:     parsedOrganizationID,
		CampaignID:         parsedCampaignID,
	}
	parsedDateTime, err := time.Parse(time.RFC3339, input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}
	// Create new activity instance
	newActivity := models.Activity{
		ID:                   uuid.New(),
		LeadID:               lead.ID,
		ActivityType:         input.ActivityType,
		DateTime:             parsedDateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}

	// Use a transaction to ensure both Lead and Activity are created successfully
	err = initializers.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&lead).Error; err != nil {
			log.Printf("Error creating lead: %v", err)
			return fmt.Errorf("internal error: failed to create lead")
		}

		if err := tx.Create(&newActivity).Error; err != nil {
			log.Printf("Error creating activity: %v", err)
			return fmt.Errorf("internal error: failed to create activity")
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Return the created lead and its associated activity
	return &generated.Lead{
		LeadID:             lead.ID.String(),
		FirstName:          lead.FirstName,
		LastName:           lead.LastName,
		Email:              lead.Email,
		LinkedIn:           lead.LinkedIn,
		Country:            lead.Country,
		Phone:              lead.Phone,
		LeadSource:         lead.LeadSource,
		InitialContactDate: lead.InitialContactDate.Format("2006-01-02"),
		LeadCreatedBy: &generated.User{
			UserID: createdByUser.ID.String(),
			Name:   createdByUser.Name,
			Email:  createdByUser.Email,
		},
		LeadAssignedTo: &generated.User{
			UserID: assignedToUser.ID.String(),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    string(lead.LeadStage),
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:   organization.ID.String(),
			OrganizationName: organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			CampaignID:   campaign.ID.String(),
			CampaignName: campaign.CampaignName,
		},
		Activities: []*generated.Activity{
			{
				ActivityID:           newActivity.ID.String(),
				LeadID:               newActivity.ID.String(),
				ActivityType:         newActivity.ActivityType,
				DateTime:             newActivity.DateTime.Format(time.RFC3339),
				CommunicationChannel: newActivity.CommunicationChannel,
				ContentNotes:         newActivity.ContentNotes,
				ParticipantDetails:   newActivity.ParticipantDetails,
				FollowUpActions:      newActivity.FollowUpActions,
			},
		},
	}, nil
}

// CreateDeal is the resolver for the createDeal field.
func (r *mutationResolver) CreateDeal(ctx context.Context, input generated.CreateDealInput) (*generated.Deal, error) {
	parsedDealStartDate, err := time.Parse(time.RFC3339, input.DealStartDate)
	if err != nil {
		return nil, fmt.Errorf("invalid DealStartDate format: %v", err)
	}
	parsedDealEndDate, err := time.Parse(time.RFC3339, input.DealEndDate)
	if err != nil {
		return nil, fmt.Errorf("invalid DealEndDate format: %v", err)
	}
	parsedLeadID, err := uuid.Parse(input.LeadID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	// Create new deal
	newDeal := models.Deal{
		LeadID:        parsedLeadID,
		DealName:      input.DealName,
		DealAmount:    input.DealAmount,
		DealStartDate: parsedDealStartDate,
		DealEndDate:   parsedDealEndDate,
		DealStatus:    input.DealStatus.String(),
	}
	if err := initializers.DB.Create(&newDeal).Error; err != nil {
		log.Printf("Error creating deal: %v", err)
		return nil, fmt.Errorf("internal error: failed to create deal")
	}
	return &generated.Deal{
		DealID:        newDeal.ID.String(),
		LeadID:        newDeal.LeadID.String(),
		DealName:      newDeal.DealName,
		DealAmount:    newDeal.DealAmount,
		DealStartDate: newDeal.DealStartDate.Format(time.RFC3339),
		DealEndDate:   newDeal.DealEndDate.Format(time.RFC3339),
		DealStatus:    newDeal.DealStatus,
	}, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input generated.CreateActivityInput) (*generated.Activity, error) {
	parsedLeadID, err := uuid.Parse(input.LeadID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}
	parsedDateTime, err := time.Parse(time.RFC3339, input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}

	// Create new activity
	newActivity := models.Activity{
		ID:                   uuid.New(),
		LeadID:               parsedLeadID,
		ActivityType:         input.ActivityType,
		DateTime:             parsedDateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}
	var lead models.Lead
	if err := initializers.DB.First(&lead, "id = ?", parsedLeadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("lead with ID %s does not exist", input.LeadID)
		}
		return nil, fmt.Errorf("error checking lead existence: %v", err)
	}

	if err := initializers.DB.Create(&newActivity).Error; err != nil {
		log.Printf("Error creating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to create activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           newActivity.ID.String(),
		LeadID:               newActivity.LeadID.String(),
		ActivityType:         newActivity.ActivityType,
		DateTime:             newActivity.DateTime.Format(time.RFC3339),
		CommunicationChannel: newActivity.CommunicationChannel,
		ContentNotes:         newActivity.ContentNotes,
		ParticipantDetails:   newActivity.ParticipantDetails,
		FollowUpActions:      newActivity.FollowUpActions,
	}, nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, activityID string, input generated.UpdateActivityInput) (*generated.Activity, error) {
	// Update activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	parsedDateTime, err := time.Parse(time.RFC3339, *input.DateTime)
	if err != nil {
		return nil, fmt.Errorf("invalid DateTime format: %v", err)
	}
	activity.ActivityType = *input.ActivityType
	activity.DateTime = parsedDateTime
	activity.CommunicationChannel = *input.CommunicationChannel
	activity.ContentNotes = *input.ContentNotes
	activity.ParticipantDetails = *input.ParticipantDetails
	activity.FollowUpActions = *input.FollowUpActions
	if err := initializers.DB.Save(&activity).Error; err != nil {
		log.Printf("Error updating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to update activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ID.String(),
		LeadID:               activity.LeadID.String(),
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime.Format(time.RFC3339),
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, activityID string) (*generated.Activity, error) {
	// Delete activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&activity).Error; err != nil {
		log.Printf("Error deleting activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to delete activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		ActivityID:           activity.ID.String(),
		LeadID:               activity.LeadID.String(),
		ActivityType:         activity.ActivityType,
		DateTime:             activity.DateTime.Format(time.RFC3339),
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// CreateResourceProfile is the resolver for the createResourceProfile field.
func (r *mutationResolver) CreateResourceProfile(ctx context.Context, input generated.CreateResourceProfileInput) (*generated.ResourceProfile, error) {
	resourceProfile := models.ResourceProfile{
		ID:              uuid.New(),
		Type:            models.ResourceType(input.Type),
		FirstName:       input.FirstName,
		LastName:        input.LastName,
		TotalExperience: input.TotalExperience,
		Status:          models.ResourceStatus(input.Status),
	}

	if input.ContactInformation != "" {
		resourceProfile.ContactInformation = []byte(input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}

	if input.VendorID != nil && *input.VendorID != "" {
		vendorID, err := uuid.Parse(*input.VendorID)
		if err != nil {
			return nil, fmt.Errorf("invalid vendor ID: %w", err)
		}
		resourceProfile.VendorID = vendorID
	}
	// Handle skills with experience years
	var resourceSkills []models.ResourceSkill
	for _, skillInput := range input.SkillInputs {
		skillID, err := uuid.Parse(skillInput.SkillID)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID: %w", err)
		}
		resourceSkills = append(resourceSkills, models.ResourceSkill{
			ResourceProfileID: resourceProfile.ID,
			SkillID:           skillID,
			ExperienceYears:   skillInput.ExperienceYears,
		})
	}

	// Save ResourceProfile and ResourceSkills in a transaction
	tx := initializers.DB.Begin()

	if err := tx.Create(&resourceProfile).Error; err != nil {
		tx.Rollback()
		return nil, fmt.Errorf("failed to create resource profile: %w", err)
	}

	if len(resourceSkills) > 0 {
		if err := tx.Create(&resourceSkills).Error; err != nil {
			tx.Rollback()
			return nil, fmt.Errorf("failed to associate skills: %w", err)
		}
	}

	tx.Commit()

	// Fetch the created resource profile along with associated skills
	var fetchedProfile models.ResourceProfile
	if err := initializers.DB.
		Preload("ResourceSkills").
		Preload("ResourceSkills.Skill").
		First(&fetchedProfile, "id = ?", resourceProfile.ID).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch resource profile: %w", err)
	}

	// Convert ResourceSkills for GraphQL response
	resourceSkillsGraphQL := utils.ConvertResourceSkills(fetchedProfile.ResourceSkills)

	// Return GraphQL response
	return &generated.ResourceProfile{
		ResourceProfileID:  resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		VendorID:           resourceProfile.VendorID.String(),
		ResourceSkills:     resourceSkillsGraphQL,
	}, nil
}

// UpdateResourceProfile is the resolver for the updateResourceProfile field.
func (r *mutationResolver) UpdateResourceProfile(ctx context.Context, resourceProfileID string, input generated.UpdateResourceProfileInput) (*generated.ResourceProfile, error) {
	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("ResourceSkills").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	// Update fields using pointers to distinguish between not provided and zero values
	if input.Type != nil {
		resourceProfile.Type = models.ResourceType(*input.Type)
	}
	if input.FirstName != nil {
		resourceProfile.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		resourceProfile.LastName = *input.LastName
	}
	if input.TotalExperience != nil {
		resourceProfile.TotalExperience = *input.TotalExperience
	}
	if input.ContactInformation != "" {
		resourceProfile.ContactInformation = []byte(input.ContactInformation)
	}

	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	if input.Status != nil {
		resourceProfile.Status = models.ResourceStatus(*input.Status)
	}
	if input.VendorID != nil && *input.VendorID != "" {
		vendorID, err := uuid.Parse(*input.VendorID)
		if err != nil {
			return nil, fmt.Errorf("invalid vendor ID: %w", err)
		}
		resourceProfile.VendorID = vendorID
	}
	// Convert string IDs to uint
	skillIDs := make([]uint, len(input.SkillIDs))
	for i, idStr := range input.SkillIDs {
		id, err := strconv.ParseUint(idStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID %s: %w", idStr, err)
		}
		skillIDs[i] = uint(id)
	}

	if len(skillIDs) > 0 {
		skills, err := utils.FetchSkills(skillIDs)
		if err != nil {
			return nil, err
		}
		if err := initializers.DB.Model(&resourceProfile).Association("Skills").Replace(skills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to update resource profile: %w", err)
	}
	if err := initializers.DB.Preload("ResourceSkills.Skill").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve updated resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() string {
			if resourceProfile.VendorID == uuid.Nil {
				return ""
			}
			return resourceProfile.VendorID.String()
		}(),

		ResourceSkills: utils.ConvertResourceSkills(resourceProfile.ResourceSkills),
	}, nil
}

// DeleteResourceProfile is the resolver for the deleteResourceProfile field.
func (r *mutationResolver) DeleteResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: DeleteResourceProfile - deleteResourceProfile"))
	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("ResourceSkills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	if err := initializers.DB.Delete(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to delete resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		VendorID: func() string {
			if resourceProfile.VendorID == uuid.Nil {
				return ""
			}
			return resourceProfile.VendorID.String()
		}(),
		ResourceSkills: utils.ConvertResourceSkills(resourceProfile.ResourceSkills),
	}, nil
}

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input generated.CreateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: CreateVendor - createVendor"))
	vendor := models.Vendor{
		CompanyName:  input.CompanyName,
		Status:       models.VendorStatus(input.Status),       // Enum conversion
		PaymentTerms: models.PaymentTerms(input.PaymentTerms), // Enum conversion
		Address:      input.Address,
	}

	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many)
	if len(input.SkillIDs) > 0 {
		var skills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			// skillID, err := uuid.Parse(skillIDStr)
			// if err != nil {
			// 	return nil, fmt.Errorf("invalid skill ID: %w", err)
			// }
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillIDStr).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			skills = append(skills, skill)
		}
		vendor.Skills = skills
	}

	if err := initializers.DB.Create(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to create vendor: %w", err)
	}
	return &generated.Vendor{
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, vendorID string, input generated.UpdateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: UpdateVendor - updateVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	if input.CompanyName != nil {
		vendor.CompanyName = *input.CompanyName
	}
	if input.Status != nil {
		vendor.Status = models.VendorStatus(*input.Status)
	}
	if input.PaymentTerms != nil {
		vendor.PaymentTerms = models.PaymentTerms(*input.PaymentTerms)
	}
	if input.Address != nil {
		vendor.Address = *input.Address
	}
	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many) - Replace existing skills.
	if input.SkillIDs != nil {
		var newSkills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			skillID, err := uuid.Parse(skillIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid skill ID: %w", err)
			}
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillID).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			newSkills = append(newSkills, skill)
		}
		if err := initializers.DB.Model(&vendor).Association("Skills").Replace(newSkills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to update vendor: %w", err)
	}
	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// DeleteVendor is the resolver for the deleteVendor field.
func (r *mutationResolver) DeleteVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: DeleteVendor - deleteVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", vendor.ID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	// GORM's soft delete.  Use Unscoped() to permanently delete (if needed).
	if err := initializers.DB.Delete(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to delete vendor: %w", err)
	}

	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input generated.CreateTaskInput) (*generated.Task, error) {
	// panic(fmt.Errorf("not implemented: CreateTask - createTask"))
	// Create the task
	jwtClaims, _ := auth.GetUserFromJWT(ctx)

	userID, okid := jwtClaims["user_id"].(string)
	name, _ := jwtClaims["name"].(string)
	fmt.Println("Name: ", name)
	fmt.Println("User ID: ", userID)
	if !okid {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	parsedUserID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}
	task := models.Task{
		ID:          uuid.New(),
		UserID:      parsedUserID, // Assuming UserID is passed in the input
		Title:       input.Title,
		Description: *input.Description,
		Status:      models.TaskStatus(input.Status),
		Priority:    models.TaskPriority(input.Priority),
		DueDate: func() *time.Time {
			if input.DueDate != "" {
				parsedTime, err := time.Parse(time.RFC3339, input.DueDate)
				if err == nil {
					return &parsedTime
				}
			}
			return nil
		}(),
	}

	// Save task to the database
	if err := initializers.DB.Create(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to create task: %w", err)
	}

	// Return created task
	return &generated.Task{
		TaskID: task.ID.String(),
		// UserID:   task.UserID,
		Title:       task.Title,
		Status:      generated.TaskStatus(task.Status),
		Priority:    generated.TaskPriority(task.Priority),
		Description: &task.Description,
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
		User: &generated.User{
			UserID: userID,
		},
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, taskID string, input generated.UpdateTaskInput) (*generated.Task, error) {
	// Find the task by taskID
	var task models.Task
	if err := initializers.DB.First(&task, "id = ?", taskID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("task with id %s not found", taskID)
		}
		return nil, fmt.Errorf("failed to find task: %w", err)
	}

	// Update task fields based on the input
	if input.Title != nil {
		task.Title = *input.Title
	}
	if input.Description != nil {
		task.Description = *input.Description
	}
	if input.Status != nil {
		task.Status = models.TaskStatus(*input.Status)
	}
	if input.Priority != nil {
		task.Priority = models.TaskPriority(*input.Priority)
	}
	if input.DueDate != nil {
		parsedDueDate, err := time.Parse(time.RFC3339, *input.DueDate)
		if err != nil {
			return nil, fmt.Errorf("invalid due date format: %v", err)
		}
		task.DueDate = &parsedDueDate
	}

	// task.UpdatedAt = time.Now().String() // Set updated timestamp

	// Save the updated task
	if err := initializers.DB.Save(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to update task: %w", err)
	}

	// Return updated task
	return &generated.Task{
		TaskID: task.ID.String(),
		// UserID:    task.UserID,
		Title:    task.Title,
		Status:   generated.TaskStatus(task.Status),
		Priority: generated.TaskPriority(task.Priority),
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
	}, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, taskID string) (*generated.Task, error) {
	var task models.Task
	if err := initializers.DB.First(&task, "id = ?", taskID).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("task with id %s not found", taskID)
		}
		return nil, fmt.Errorf("failed to find task: %w", err)
	}

	// Delete the task
	if err := initializers.DB.Delete(&task).Error; err != nil {
		return nil, fmt.Errorf("failed to delete task: %w", err)
	}

	// Return deleted task
	return &generated.Task{
		TaskID: task.ID.String(),
		User: &generated.User{
			UserID: task.UserID.String(),
		},
		Title:    task.Title,
		Status:   generated.TaskStatus(task.Status),
		Priority: generated.TaskPriority(task.Priority),
		DueDate: func() string {
			if task.DueDate != nil {
				return task.DueDate.Format(time.RFC3339)
			}
			return ""
		}(),
	}, nil
}

// CreateCaseStudy is the resolver for the createCaseStudy field.
func (r *mutationResolver) CreateCaseStudy(ctx context.Context, input generated.CreateCaseStudyInput) (*generated.CaseStudy, error) {
	// Ensure database connection is initialized
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	if input.ProjectName == "" || input.ClientName == "" {
		return nil, fmt.Errorf("project name and client name are required")
	}

	// Create a new case study instance
	caseStudy := models.CaseStudy{
		ID:              uuid.New(), // Ensure UUID is generated if using UUID as the primary key
		ProjectName:     input.ProjectName,
		ClientName:      input.ClientName,
		TechStack:       input.TechStack,
		ProjectDuration: input.ProjectDuration,
		KeyOutcomes:     input.KeyOutcomes,
		IndustryTarget:  input.IndustryTarget,
		Tags:            input.Tags,
		Document:        input.Document,
	}

	// Insert into the database
	if err := initializers.DB.Create(&caseStudy).Error; err != nil {
		return nil, fmt.Errorf("failed to create case study: %v", err)
	}

	// Convert to GraphQL response type
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(), // Ensure consistent UUID usage
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// UpdateCaseStudy is the resolver for the updateCaseStudy field.
func (r *mutationResolver) UpdateCaseStudy(ctx context.Context, caseStudyID string, input generated.UpdateCaseStudyInput) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: UpdateCaseStudy - updateCaseStudy"))
	var caseStudy models.CaseStudy

	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, fmt.Errorf("case study with ID %s not found", caseStudyID) // Case study not found
	}

	if input.ProjectName != "" {
		caseStudy.ProjectName = input.ProjectName
	}
	if input.ClientName != "" {
		caseStudy.ClientName = input.ClientName
	}
	if input.TechStack != "" {
		caseStudy.TechStack = input.TechStack
	}
	if input.ProjectDuration != "" {
		caseStudy.ProjectDuration = input.ProjectDuration
	}
	if input.KeyOutcomes != "" {
		caseStudy.KeyOutcomes = input.KeyOutcomes
	}
	if input.IndustryTarget != "" {
		caseStudy.IndustryTarget = input.IndustryTarget
	}
	if input.Tags != "" {
		caseStudy.Tags = input.Tags
	}
	if input.Document != "" {
		caseStudy.Document = input.Document
	}

	if err := initializers.DB.Save(&caseStudy).Error; err != nil {
		return nil, err
	}

	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// DeleteCaseStudy is the resolver for the deleteCaseStudy field.
func (r *mutationResolver) DeleteCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: DeleteCaseStudy - deleteCaseStudy"))
	var caseStudy models.CaseStudy
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, err // Case study not found
	}
	if err := initializers.DB.Delete(&caseStudy).Error; err != nil {
		return nil, err
	}
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// CreateSkill is the resolver for the createSkill field.
func (r *mutationResolver) CreateSkill(ctx context.Context, input generated.CreateSkillInput) (*generated.Skill, error) {
	// Validate JWT user
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if skill already exists
	var existingSkill models.Skill
	if err := initializers.DB.Where("name = ?", input.Name).First(&existingSkill).Error; err == nil {
		return nil, errors.New("skill already exists")
	}

	// Create new skill
	newSkill := models.Skill{
		ID:          uuid.New(),
		Name:        input.Name,
		Description: input.Description,
		SkillType:   models.SkillType(input.Skilltype),
	}

	// Insert into database
	if err := initializers.DB.Create(&newSkill).Error; err != nil {
		return nil, fmt.Errorf("failed to create skill: %v", err)
	}

	// Return the created skill
	return &generated.Skill{
		SkillID:     newSkill.ID.String(),
		Name:        newSkill.Name,
		Description: *newSkill.Description,
		Skilltype:   generated.SkillType(newSkill.SkillType),
	}, nil
}

// UpdateSkill is the resolver for the updateSkill field.
func (r *mutationResolver) UpdateSkill(ctx context.Context, skillID string, input generated.UpdateSkillInput) (*generated.Skill, error) {
	// panic(fmt.Errorf("not implemented: UpdateSkill - updateSkill"))
	// Validate JWT user
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}
	// Find the skill to update
	var skill models.Skill
	if err := initializers.DB.Where("id = ?", skillID).First(&skill).Error; err != nil {

		return nil, errors.New("skill not found")
	}
	// Update the skill
	skill.Name = *input.Name
	skill.Description = input.Description
	skill.SkillType = models.SkillType(*input.Skilltype)
	if err := initializers.DB.Save(&skill).Error; err != nil {
		return nil, fmt.Errorf("failed to update skill: %v", err)
	}
	// Return the updated skill
	return &generated.Skill{
		SkillID:     skill.ID.String(),
		Name:        skill.Name,
		Description: *skill.Description,
		Skilltype:   generated.SkillType(skill.SkillType),
	}, nil
}

// DeleteSkill is the resolver for the deleteSkill field.
func (r *mutationResolver) DeleteSkill(ctx context.Context, skillID string) (*generated.Skill, error) {
	// panic(fmt.Errorf("not implemented: DeleteSkill - deleteSkill"))
	// Validate JWT user
	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}
	// Find the skill to delete
	var skill models.Skill
	if err := initializers.DB.Where("id = ?", skillID).First(&skill).Error; err != nil {
		return nil, errors.New("skill not found")
	}
	// Delete the skill
	if err := initializers.DB.Delete(&skill).Error; err != nil {
		return nil, fmt.Errorf("failed to delete skill: %v", err)
	}
	// Return the deleted skill
	return &generated.Skill{
		SkillID: skill.ID.String(),
		Name:    skill.Name,
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, filter *generated.UserFilter, pagination *generated.PaginationInput, sort *generated.UserSortInput) (*generated.UserPage, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized %s", err)
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to get user")
	}

	var users []models.User
	query := initializers.DB.Model(&models.User{}).
		Joins("LEFT JOIN campaign_users ON users.id = campaign_users.user_id").
		Joins("LEFT JOIN campaigns ON campaign_users.campaign_id = campaigns.id").
		Preload("Campaigns")

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("users.name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("users.email ILIKE ?", "%"+*filter.Email+"%")
		}
		if filter.Role != nil && *filter.Role != "" {
			query = query.Where("users.role = ?", *filter.Role)
		}
		if filter.Search != nil && *filter.Search != "" {
			query = query.Where("users.name ILIKE ? OR users.email ILIKE ?", "%"+*filter.Search+"%", "%"+*filter.Search+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.UserSortFieldName:
			query = query.Order("users.name " + order)
		case generated.UserSortFieldEmail:
			query = query.Order("users.email " + order)
		case generated.UserSortFieldRole:
			query = query.Order("users.role " + order)
		case generated.UserSortFieldCreatedAt:
			query = query.Order("users.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := int((pagination.Page - 1) * pagination.PageSize)
		query = query.Offset(offset).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&users).Error; err != nil {
		log.Printf("Error fetching users: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch users")
	}

	// Map to GraphQL response type
	var result []*generated.User
	for _, c := range users {
		var campaigns []*generated.Campaign
		for _, u := range c.Campaigns {
			campaigns = append(campaigns, &generated.Campaign{
				CampaignID:       u.ID.String(),
				CampaignName:     u.CampaignName,
				CampaignCountry:  u.CampaignCountry,
				CampaignRegion:   u.CampaignRegion,
				IndustryTargeted: u.IndustryTargeted,
			})
		}
		result = append(result, &generated.User{
			UserID:    c.ID.String(),
			GoogleID:  &c.GoogleId,
			Name:      c.Name,
			Email:     c.Email,
			Phone:     c.Phone,
			Role:      c.Role,
			Password:  c.Password,
			Campaigns: campaigns,
		})
	}

	return &generated.UserPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	// Find the user by ID and preload campaigns
	var user models.User
	if err := initializers.DB.Preload("Campaigns").First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Map campaigns
	var campaigns []*generated.Campaign
	for _, c := range user.Campaigns {
		campaigns = append(campaigns, &generated.Campaign{
			CampaignID:       c.ID.String(),
			CampaignName:     c.CampaignName,
			CampaignCountry:  c.CampaignCountry,
			CampaignRegion:   c.CampaignRegion,
			IndustryTargeted: c.IndustryTargeted,
		})
	}

	// Map the user to the GraphQL response type
	return &generated.User{
		UserID:    user.ID.String(),
		GoogleID:  &user.GoogleId,
		Name:      user.Name,
		Email:     user.Email,
		Phone:     user.Phone,
		Role:      user.Role,
		Password:  user.Password,
		Campaigns: campaigns, // Include campaigns in response
	}, nil
}

// GetCampaigns is the resolver for the getCampaigns field.
func (r *queryResolver) GetCampaigns(ctx context.Context, filter *generated.CampaignFilter, pagination *generated.PaginationInput, sort *generated.CampaignSortInput) (*generated.CampaignPage, error) {
	var campaigns []models.Campaign

	// Preload Users so that each Campaign comes with its associated users.
	query := initializers.DB.Model(&models.Campaign{}).Preload("Users")

	// --- Apply Filters ---
	if filter != nil {
		if filter.CampaignName != nil && *filter.CampaignName != "" {
			query = query.Where("campaigns.campaign_name ILIKE ?", "%"+*filter.CampaignName+"%")
		}
		if filter.CampaignCountry != nil && *filter.CampaignCountry != "" {
			query = query.Where("campaigns.campaign_country = ?", *filter.CampaignCountry)
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.CampaignSortFieldCampaignName:
			query = query.Order("campaigns.campaign_name " + order)
		case generated.CampaignSortFieldCreatedAt:
			query = query.Order("campaigns.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&campaigns).Error; err != nil {
		log.Printf("Error fetching campaigns: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch campaigns")
	}

	// Map the campaigns to your GraphQL type, including the associated users.
	var result []*generated.Campaign
	for _, c := range campaigns {
		// Map associated users for each campaign.
		var users []*generated.User
		for _, u := range c.Users {
			users = append(users, &generated.User{
				UserID:   u.ID.String(),
				GoogleID: &u.GoogleId,
				Name:     u.Name,
				Email:    u.Email,
				Role:     u.Role,
				Phone:    u.Phone,
				// You can map additional fields as needed.
			})
		}

		result = append(result, &generated.Campaign{
			CampaignID:      c.ID.String(),
			CampaignName:    c.CampaignName,
			CampaignCountry: c.CampaignCountry,
			// Map additional campaign fields if needed.
			Users: users, // This field should be defined in your GraphQL Campaign type.
		})
	}

	return &generated.CampaignPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetCampaign is the resolver for the getCampaign field.
func (r *queryResolver) GetCampaign(ctx context.Context, campaignID string) (*generated.Campaign, error) {
	// Retrieve the campaign with the given ID, preloading the associated Users.
	var campaign models.Campaign
	if err := initializers.DB.
		Preload("Users").
		Where("id = ?", campaignID).
		First(&campaign).Error; err != nil {
		log.Printf("Error fetching campaign %s: %v", campaignID, err)
		return nil, fmt.Errorf("internal error: failed to fetch campaign")
	}

	// Map the associated users to the GraphQL type.
	var users []*generated.User
	for _, u := range campaign.Users {
		users = append(users, &generated.User{
			UserID:   u.ID.String(),
			GoogleID: &u.GoogleId,
			Name:     u.Name,
			Email:    u.Email,
			Role:     u.Role,
			Phone:    u.Phone,
			// Map any additional user fields as needed.
		})
	}

	// Map the campaign to the GraphQL type, including the nested users.
	result := &generated.Campaign{
		CampaignID:      campaign.ID.String(),
		CampaignName:    campaign.CampaignName,
		CampaignCountry: campaign.CampaignCountry,
		// Include any additional campaign fields as needed.
		Users: users,
	}

	return result, nil
}

// GetLeads is the resolver for the getLeads field.
func (r *queryResolver) GetLeads(ctx context.Context, filter *generated.LeadFilter, pagination *generated.PaginationInput, sort *generated.LeadSortInput) (*generated.LeadPage, error) {
	// panic(fmt.Errorf("not implemented: GetLeads - getLeads"))
	log.Println("GetAllLeads called")

	var leads []models.Lead
	query := initializers.DB.Model(&models.Lead{})
	query = query.
		Preload("Creator").
		Preload("Assignee").
		Preload("Organization").
		Preload("Campaign").
		Preload("Activities")

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("leads.first_name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("leads.email ILIKE ?", "%"+*filter.Email+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.LeadSortFieldFirstName:
			query = query.Order("leads.first_name " + order)
		case generated.LeadSortFieldLastName:
			query = query.Order("leads.last_name " + order)
		case generated.LeadSortFieldEmail:
			query = query.Order("leads.email " + order)
		case generated.LeadSortFieldCreatedAt:
			query = query.Order("leads.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&leads).Error; err != nil {
		log.Printf("Error fetching leads: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch leads")
	}

	// Map to GraphQL response type
	var result []*generated.Lead

	for _, lead := range leads {
		var activities []*generated.Activity
		for _, activity := range lead.Activities {
			activities = append(activities, &generated.Activity{
				ActivityID:           activity.ID.String(),
				LeadID:               activity.LeadID.String(),
				ActivityType:         activity.ActivityType,
				DateTime:             activity.DateTime.Format("2006-01-02"),
				CommunicationChannel: activity.CommunicationChannel,
				ContentNotes:         activity.ContentNotes,
				ParticipantDetails:   activity.ParticipantDetails,
				FollowUpActions:      activity.FollowUpActions,
			})
		}

		// Map Organization
		var organization *generated.Organization
		if lead.OrganizationID != uuid.Nil {
			organization = &generated.Organization{
				OrganizationID:    lead.Organization.ID.String(),
				OrganizationName:  lead.Organization.OrganizationName,
				OrganizationEmail: lead.Organization.OrganizationEmail,
			}
		}

		// Map Campaign
		var campaign *generated.Campaign
		if lead.CampaignID != uuid.Nil {
			campaign = &generated.Campaign{
				CampaignID:       lead.Campaign.ID.String(),
				CampaignName:     lead.Campaign.CampaignName,
				CampaignCountry:  lead.Campaign.CampaignCountry,
				CampaignRegion:   lead.Campaign.CampaignRegion,
				IndustryTargeted: lead.Campaign.IndustryTargeted,
			}
		}

		result = append(result, &generated.Lead{
			LeadID:     lead.ID.String(),
			FirstName:  lead.FirstName,
			LastName:   lead.LastName,
			LinkedIn:   lead.LinkedIn,
			Email:      lead.Email,
			Country:    lead.Country,
			Phone:      lead.Phone,
			LeadSource: lead.LeadSource,
			LeadCreatedBy: &generated.User{
				UserID: lead.LeadCreatedBy.String(),
				Name:   lead.Creator.Name,
				Email:  lead.Creator.Email,
			},
			LeadAssignedTo: &generated.User{
				UserID: lead.LeadAssignedTo.String(),
				Name:   lead.Assignee.Name,
				Email:  lead.Assignee.Email,
			},
			LeadStage:          string(lead.LeadStage),
			LeadPriority:       lead.LeadPriority,
			LeadNotes:          lead.LeadNotes,
			InitialContactDate: lead.InitialContactDate.Format("2006-01-02"),
			Activities:         activities,
			Organization:       organization,
			Campaign:           campaign,
		})

	}

	return &generated.LeadPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetLead is the resolver for the getLead field.
func (r *queryResolver) GetLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: GetLead - getLead"))
	role, _ := auth.GetUserRoleFromJWT(ctx)
	if role == "" {
		fmt.Println("Role is empty")
		return nil, fmt.Errorf("missing token")
	}

	// Find the lead by ID
	var lead models.Lead
	if err := initializers.DB.
		Preload("Activities").
		Preload("Organization").
		Preload("Campaign").
		Preload("Creator").
		Preload("Assignee").
		First(&lead, "id = ?", leadID).Error; err != nil {
		return nil, err
	}

	// Map the lead to the GraphQL response type
	var activities []*generated.Activity
	for _, activity := range lead.Activities {
		activities = append(activities, &generated.Activity{
			ActivityID:           activity.ID.String(),
			ActivityType:         activity.ActivityType,
			DateTime:             activity.DateTime.Format("2006-01-02"),
			CommunicationChannel: activity.CommunicationChannel,
			ContentNotes:         activity.ContentNotes,
			ParticipantDetails:   activity.ParticipantDetails,
		})
	}

	// Map Organization
	var organization *generated.Organization
	if lead.OrganizationID != uuid.Nil {
		organization = &generated.Organization{
			OrganizationID:      lead.OrganizationID.String(),
			OrganizationName:    lead.Organization.OrganizationName,
			OrganizationEmail:   lead.Organization.OrganizationEmail,
			OrganizationWebsite: &lead.Organization.OrganizationWebsite,
		}
	}

	// // Map Campaign
	var campaign *generated.Campaign
	if lead.CampaignID != uuid.Nil {
		campaign = &generated.Campaign{
			CampaignID:       lead.Campaign.ID.String(),
			CampaignName:     lead.Campaign.CampaignName,
			CampaignCountry:  lead.Campaign.CampaignCountry,
			CampaignRegion:   lead.Campaign.CampaignRegion,
			IndustryTargeted: lead.Campaign.IndustryTargeted,
		}
	}

	// Map the lead to the GraphQL response type
	return &generated.Lead{
		LeadID:     lead.ID.String(),
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		LeadCreatedBy: &generated.User{
			UserID: lead.LeadCreatedBy.String(),
			Name:   lead.Creator.Name,
			Email:  lead.Creator.Email,
		},
		LeadAssignedTo: &generated.User{
			UserID: lead.LeadAssignedTo.String(),
			Name:   lead.Assignee.Name,
			Email:  lead.Assignee.Email,
		},
		LeadStage:          string(lead.LeadStage),
		LeadPriority:       lead.LeadPriority,
		LeadNotes:          lead.LeadNotes,
		InitialContactDate: lead.InitialContactDate.Format("2006-01-02"),
		Activities:         activities,
		Organization:       organization,
		Campaign:           campaign,
	}, nil
}

// GetOrganizations is the resolver for the getOrganizations field.
func (r *queryResolver) GetOrganizations(ctx context.Context, filter *generated.OrganizationFilter, sort *generated.OrganizationSortInput, pagination *generated.PaginationInput) (*generated.OrganizationPage, error) {
	var organizations []models.Organization
	query := initializers.DB.Model(&models.Organization{})

	// Apply filters
	if filter != nil {
		if filter.Search != nil && *filter.Search != "" {
			query = query.Where("organization_name ILIKE ?", "%"+*filter.Search+"%")
		}
		if filter.Country != nil && *filter.Country != "" {
			query = query.Where("country = ?", *filter.Country)
		}
		if filter.MinEmployees != nil {
			query = query.Where("no_of_employees::INTEGER >= ?", *filter.MinEmployees)
		}
		if filter.MaxEmployees != nil {
			query = query.Where("no_of_employees::INTEGER <= ?", *filter.MaxEmployees)
		}
	}

	// Sorting logic
	if sort != nil {
		var sortColumn string
		switch sort.Field {
		case generated.OrganizationSortFieldOrganizationName:
			sortColumn = "organization_name"
		case generated.OrganizationSortFieldCountry:
			sortColumn = "country"
		case generated.OrganizationSortFieldNoOfEmployees:
			sortColumn = "no_of_employees"
		case generated.OrganizationSortFieldAnnualRevenue:
			sortColumn = "annual_revenue"
		}

		if sort.Order == generated.SortOrderDesc {
			sortColumn += " DESC"
		} else {
			sortColumn += " ASC"
		}
		query = query.Order(sortColumn)
	}

	// Get total count before pagination
	var totalCount int64
	query.Count(&totalCount)

	// Pagination logic
	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&organizations).Error; err != nil {
		log.Printf("Error fetching organizations: %v", err)
		return nil, err
	}

	// Convert to GraphQL response type
	var result []*generated.Organization
	for _, org := range organizations {
		result = append(result, &generated.Organization{
			OrganizationID:      org.ID.String(),
			OrganizationName:    org.OrganizationName,
			OrganizationEmail:   org.OrganizationEmail,
			OrganizationWebsite: &org.OrganizationWebsite,
			City:                org.City,
			Country:             org.Country,
			NoOfEmployees:       org.NoOfEmployees,
			AnnualRevenue:       org.AnnualRevenue,
		})
	}

	return &generated.OrganizationPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetOrganization is the resolver for the getOrganization field.
func (r *queryResolver) GetOrganization(ctx context.Context, organizationID string) (*generated.Organization, error) {
	// panic(fmt.Errorf("not implemented: GetOrganization - getOrganization"))
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id=?", organizationID).Error; err != nil {
		return nil, fmt.Errorf("organization not found: %w", err)
	}

	// Convert to GraphQL response type
	return &generated.Organization{
		OrganizationID:      organization.ID.String(),
		OrganizationName:    organization.OrganizationName,
		OrganizationEmail:   organization.OrganizationEmail,
		OrganizationWebsite: &organization.OrganizationWebsite,
		City:                organization.City,
		Country:             organization.Country,
		NoOfEmployees:       organization.NoOfEmployees,
		AnnualRevenue:       organization.AnnualRevenue,
	}, nil
}

// GetResourceProfiles is the resolver for the getResourceProfiles field.
// func (r *queryResolver) GetResourceProfiles(ctx context.Context, filter *generated.ResourceProfileFilter, pagination *generated.PaginationInput, sort *generated.ResourceProfileSortInput) (*generated.ResourceProfilePage, error) {
// 	// panic(fmt.Errorf("not implemented: GetResourceProfiles - getResourceProfiles"))
// 	var resourceProfiles []models.ResourceProfile
// 	var totalCount int64

// 	db := initializers.DB.Model(&models.ResourceProfile{})

// 	// Apply filtering
// 	if filter != nil {
// 		if filter.Type != nil {
// 			db = db.Where("type = ?", *filter.Type)
// 		}
// 		if filter.FirstName != nil {
// 			db = db.Where("first_name ILIKE ?", "%"+*filter.FirstName+"%")
// 		}
// 		if filter.LastName != nil {
// 			db = db.Where("last_name ILIKE ?", "%"+*filter.LastName+"%")
// 		}
// 		if filter.TotalExperienceMin != nil {
// 			db = db.Where("total_experience >= ?", *filter.TotalExperienceMin)
// 		}
// 		if filter.TotalExperienceMax != nil {
// 			db = db.Where("total_experience <= ?", *filter.TotalExperienceMax)
// 		}
// 		if filter.Status != nil {
// 			db = db.Where("status = ?", *filter.Status)
// 		}
// 		if filter.VendorID != nil {
// 			db = db.Where("vendor_id = ?", *filter.VendorID)
// 		}
// 		if filter.Search != nil {
// 			searchPattern := "%" + *filter.Search + "%"
// 			db = db.Where(
// 				"first_name ILIKE ? OR last_name ILIKE ? OR EXISTS (SELECT 1 FROM vendors WHERE vendors.id = resource_profiles.vendor_id AND vendors.company_name ILIKE ?)",
// 				searchPattern, searchPattern, searchPattern,
// 			)
// 		}
// 		if len(filter.SkillIDs) > 0 {
// 			// Join with the resource_skills table and filter by skill IDs
// 			db = db.Joins("JOIN resource_skills ON resource_skills.resource_profile_id = resource_profiles.id").
// 				Where("resource_skills.skill_id IN ?", filter.SkillIDs)
// 		}
// 	}
// 	// Apply sorting
// 	if sort != nil {
// 		var sortOrder string
// 		if sort.Order == generated.SortOrderAsc {
// 			sortOrder = "asc"
// 		} else {
// 			sortOrder = "desc"
// 		}

// 		switch sort.Field {
// 		case generated.ResourceProfileSortFieldCreatedAt:
// 			db = db.Order("created_at " + sortOrder)
// 		case generated.ResourceProfileSortFieldUpdatedAt:
// 			db = db.Order("updated_at " + sortOrder)
// 		case generated.ResourceProfileSortFieldFirstName:
// 			db = db.Order("first_name " + sortOrder)
// 		case generated.ResourceProfileSortFieldLastName:
// 			db = db.Order("last_name " + sortOrder)
// 		case generated.ResourceProfileSortFieldTotalExperience:
// 			db = db.Order("total_experience " + sortOrder)
// 		case generated.ResourceProfileSortFieldStatus:
// 			db = db.Order("status " + sortOrder)
// 		default:
// 			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
// 		}
// 	} else {
// 		//default sorting
// 		db = db.Order("created_at desc")
// 	}

// 	// Count total records before applying limit/offset for pagination
// 	db.Count(&totalCount)
// 	// Apply pagination
// 	if pagination != nil {
// 		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
// 	}

// 	// Execute the query
// 	if err := db.Preload("Skills").Preload("Vendor").Find(&resourceProfiles).Error; err != nil {
// 		return nil, fmt.Errorf("failed to retrieve resource profiles: %w", err)
// 	}

// 	// Convert to generated type
// 	generatedProfiles := make([]*generated.ResourceProfile, len(resourceProfiles))
// 	for i, profile := range resourceProfiles {

// 		//convert pastProjects
// 		var generatedPastProjects []*generated.PastProject

// 		generatedProfiles[i] = &generated.ResourceProfile{
// 			// ID:                 profile.ID.String(),
// 			Type:               generated.ResourceType(profile.Type),
// 			FirstName:          profile.FirstName,
// 			LastName:           profile.LastName,
// 			TotalExperience:    profile.TotalExperience,
// 			Status:             generated.ResourceStatus(profile.Status),
// 			ContactInformation: string(profile.ContactInformation),
// 			GoogleDriveLink:    profile.GoogleDriveLink,
// 			// VendorID: func() string {
// 			// 	if profile.VendorID == "" {
// 			// 		return ""
// 			// 	}
// 			// 	return profile.VendorID
// 			// }(),
// 			Vendor: func() *generated.Vendor { // Handle Vendor conversion
// 				// if profile.Vendor == nil {
// 				// 	return nil
// 				// }
// 				return &generated.Vendor{
// 					// ID:          profile.Vendor.ID.String(),
// 					// CompanyName: profile.Vendor.CompanyName,
// 					// Status:      generated.VendorStatus(profile.Vendor.Status),
// 					// ... other Vendor fields ...
// 					//convert skills
// 					Skills: []*generated.Skill{},
// 					//convert contact list
// 					ContactList: []*generated.Contact{},
// 					//convert performance ratings
// 					PerformanceRatings: []*generated.PerformanceRating{},
// 					//convert resources
// 					Resources: []*generated.ResourceProfile{},
// 				}
// 			}(),
// 			// Skills:       utils.ConvertSkills(profile.Skills), // Use the helper function
// 			PastProjects: generatedPastProjects,
// 		}
// 	}

// 	return &generated.ResourceProfilePage{
// 		Items:      generatedProfiles,
// 		TotalCount: int32(totalCount),
// 	}, nil
// }

// // GetResourceProfile is the resolver for the getResourceProfile field.
// func (r *queryResolver) GetResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
// 	// panic(fmt.Errorf("not implemented: GetResourceProfile - getResourceProfile"))
// 	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
// 	if err != nil {
// 		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
// 	}

// 	var resourceProfile models.ResourceProfile
// 	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
// 		if errors.Is(err, gorm.ErrRecordNotFound) {
// 			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
// 		}
// 		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
// 	}

// 	//convert pastProjects
// 	var generatedPastProjects []*generated.PastProject

// 	return &generated.ResourceProfile{
// 		// ID:                 resourceProfile.ID.String(),
// 		Type:               generated.ResourceType(resourceProfile.Type),
// 		FirstName:          resourceProfile.FirstName,
// 		LastName:           resourceProfile.LastName,
// 		TotalExperience:    resourceProfile.TotalExperience,
// 		Status:             generated.ResourceStatus(resourceProfile.Status),
// 		ContactInformation: string(resourceProfile.ContactInformation),
// 		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
// 		// VendorID: func() string {
// 		// 	if resourceProfile.VendorID == "" {
// 		// 		return ""
// 		// 	}
// 		// 	return resourceProfile.VendorID
// 		// }(),
// 		Vendor: func() *generated.Vendor { // Handle the nested Vendor conversion
// 			// if resourceProfile.Vendor == nil {
// 			// 	return nil
// 			// }
// 			return &generated.Vendor{
// 				// ID:          resourceProfile.Vendor.ID.String(),
// 				// CompanyName: resourceProfile.Vendor.CompanyName,
// 				// Status:      generated.VendorStatus(resourceProfile.Vendor.Status),
// 				// ... other Vendor fields ...
// 				//convert skills
// 				Skills: []*generated.Skill{},
// 				//convert contact list
// 				ContactList: []*generated.Contact{},
// 				//convert performance ratings
// 				PerformanceRatings: []*generated.PerformanceRating{},
// 				//convert resources
// 				Resources: []*generated.ResourceProfile{},
// 			}
// 		}(),
// 		// Skills:       utils.ConvertSkills(resourceProfile.Skills), // Convert skills
// 		PastProjects: generatedPastProjects,
// 	}, nil
// }

func (r *queryResolver) GetResourceProfiles(ctx context.Context, filter *generated.ResourceProfileFilter, pagination *generated.PaginationInput, sort *generated.ResourceProfileSortInput) (*generated.ResourceProfilePage, error) {
	log.Println("GetResourceProfiles called")

	var resourceProfiles []models.ResourceProfile
	query := initializers.DB.Model(&models.ResourceProfile{})

	// Preload associations.  This is correct.
	query = query.
		Preload("ResourceSkills").
		Preload("ResourceSkills.Skill").
		Preload("VendorID").
		Preload("PastProjects")

	// --- Apply Filters --- (Correct)
	if filter != nil {
		if filter.Type != nil {
			query = query.Where("resource_profiles.type = ?", filter.Type)
		}
		if filter.FirstName != nil && *filter.FirstName != "" {
			query = query.Where("resource_profiles.first_name ILIKE ?", "%"+*filter.FirstName+"%")
		}
		if filter.LastName != nil && *filter.LastName != "" {
			query = query.Where("resource_profiles.last_name ILIKE ?", "%"+*filter.LastName+"%")
		}
		if filter.TotalExperienceMin != nil {
			query = query.Where("resource_profiles.total_experience >= ?", *filter.TotalExperienceMin)
		}
		if filter.TotalExperienceMax != nil {
			query = query.Where("resource_profiles.total_experience <= ?", *filter.TotalExperienceMax)
		}
		if filter.Status != nil {
			query = query.Where("resource_profiles.status = ?", filter.Status)
		}
		if filter.VendorID != nil && *filter.VendorID != "" {
			query = query.Where("resource_profiles.vendor_id = ?", *filter.VendorID)
		}
		if filter.SkillIDs != nil && len(filter.SkillIDs) > 0 {
			query = query.Joins("JOIN resource_skills ON resource_skills.resource_profile_id = resource_profiles.id").
				Where("resource_skills.skill_id IN ?", filter.SkillIDs)
		}

		if filter.Search != nil && *filter.Search != "" {
			search := "%" + *filter.Search + "%"
			query = query.Where(`resource_profiles.first_name ILIKE ? OR resource_profiles.last_name ILIKE ? OR 
				EXISTS (SELECT 1 FROM resource_skills rs JOIN skills s ON rs.skill_id = s.id 
				WHERE rs.resource_profile_id = resource_profiles.id AND s.name ILIKE ?)`,
				search, search, search)
		}
	}

	// --- Apply Sorting --- (Correct)
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.ResourceProfileSortFieldCreatedAt:
			query = query.Order("resource_profiles.created_at " + order)
		case generated.ResourceProfileSortFieldUpdatedAt:
			query = query.Order("resource_profiles.updated_at " + order)
		case generated.ResourceProfileSortFieldFirstName:
			query = query.Order("resource_profiles.first_name " + order)
		case generated.ResourceProfileSortFieldLastName:
			query = query.Order("resource_profiles.last_name " + order)
		case generated.ResourceProfileSortFieldTotalExperience:
			query = query.Order("resource_profiles.total_experience " + order)
		case generated.ResourceProfileSortFieldStatus:
			query = query.Order("resource_profiles.status " + order)
		default:
			query = query.Order("resource_profiles.created_at DESC")
		}
	} else {
		query = query.Order("resource_profiles.created_at DESC")
	}

	// --- Apply Pagination --- (Correct)
	var totalCount int64
	query.Count(&totalCount)

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query (Correct)
	if err := query.Find(&resourceProfiles).Error; err != nil {
		log.Printf("Error fetching resource profiles: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch resource profiles")
	}

	// Map to GraphQL response type
	var result []*generated.ResourceProfile
	for _, profile := range resourceProfiles {
		resourceSkillsGraphQL := utils.ConvertResourceSkills(profile.ResourceSkills)

		var pastProjects []*generated.PastProject
		for _, project := range profile.PastProjects {
			pastProjects = append(pastProjects, &generated.PastProject{
				PastProjectID:     project.ID.String(),
				CreatedAt:         project.CreatedAt.Format(time.RFC3339),
				UpdatedAt:         project.UpdatedAt.Format(time.RFC3339),
				ResourceProfileID: project.ResourceProfileID.String(),
				ProjectName:       project.ProjectName,
				Description:       &project.Description, // Correct
			})
		}

		// Map Vendor:  Directly use profile.Vendor (it's already loaded!)
		var vendor *generated.Vendor
		if profile.VendorID != uuid.Nil { // Check if Vendor exists
			var vendorModel models.Vendor
			if err := initializers.DB.First(&vendorModel, "id = ?", profile.VendorID).Error; err == nil {
				vendor = &generated.Vendor{
					VendorID:        vendorModel.ID.String(),
					CreatedAt:       vendorModel.CreatedAt.Format(time.RFC3339),
					UpdatedAt:       vendorModel.UpdatedAt.Format(time.RFC3339),
					CompanyName:     vendorModel.CompanyName,
					Status:          generated.VendorStatus(vendorModel.Status),
					PaymentTerms:    generated.PaymentTerms(vendorModel.PaymentTerms),
					Address:         vendorModel.Address,
					GstOrVatDetails: vendorModel.GstOrVatDetails,
					Notes:           vendorModel.Notes,
				}
			}
		}

		result = append(result, &generated.ResourceProfile{
			ResourceProfileID:  profile.ID.String(),
			Type:               generated.ResourceType(profile.Type),
			FirstName:          profile.FirstName,
			LastName:           profile.LastName,
			TotalExperience:    profile.TotalExperience,
			ContactInformation: string(profile.ContactInformation),
			GoogleDriveLink:    profile.GoogleDriveLink,
			Status:             generated.ResourceStatus(profile.Status),
			VendorID:           profile.VendorID.String(), // Keep VendorID
			Vendor:             vendor,                    // Correctly set the vendor
			ResourceSkills:     resourceSkillsGraphQL,
			PastProjects:       pastProjects,
		})
	}

	return &generated.ResourceProfilePage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetResourceProfile is the resolver for the getResourceProfile field.
func (r *queryResolver) GetResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	log.Println("GetResourceProfile called")

	var profile models.ResourceProfile

	// Validate the UUID
	if _, err := uuid.Parse(resourceProfileID); err != nil {
		return nil, fmt.Errorf("invalid resource profile ID")
	}

	// Preload necessary associations. This is correct.
	if err := initializers.DB.
		Preload("ResourceSkills").
		Preload("ResourceSkills.Skill").
		Preload("Vendor").
		Preload("PastProjects").
		First(&profile, "id = ?", resourceProfileID).Error; err != nil {
		log.Printf("Error fetching resource profile: %v", err)
		return nil, fmt.Errorf("resource profile not found")
	}

	resourceSkillsGraphQL := utils.ConvertResourceSkills(profile.ResourceSkills)

	var pastProjects []*generated.PastProject
	for _, project := range profile.PastProjects {
		pastProjects = append(pastProjects, &generated.PastProject{
			PastProjectID:     project.ID.String(),
			CreatedAt:         project.CreatedAt.Format(time.RFC3339),
			UpdatedAt:         project.UpdatedAt.Format(time.RFC3339),
			ResourceProfileID: project.ResourceProfileID.String(),
			ProjectName:       project.ProjectName,
			Description:       &project.Description, // Correct
		})
	}

	// Fetch Vendor details using VendorID
	var vendor *generated.Vendor
	if profile.VendorID != uuid.Nil { // Check if VendorID exists
		var vendorModel models.Vendor
		if err := initializers.DB.First(&vendorModel, "id = ?", profile.VendorID).Error; err == nil {
			vendor = &generated.Vendor{
				VendorID:        vendorModel.ID.String(),
				CreatedAt:       vendorModel.CreatedAt.Format(time.RFC3339),
				UpdatedAt:       vendorModel.UpdatedAt.Format(time.RFC3339),
				CompanyName:     vendorModel.CompanyName,
				Status:          generated.VendorStatus(vendorModel.Status),
				PaymentTerms:    generated.PaymentTerms(vendorModel.PaymentTerms),
				Address:         vendorModel.Address,
				GstOrVatDetails: vendorModel.GstOrVatDetails,
				Notes:           vendorModel.Notes,
			}
		}
	}

	return &generated.ResourceProfile{
		ResourceProfileID:  profile.ID.String(),
		Type:               generated.ResourceType(profile.Type),
		FirstName:          profile.FirstName,
		LastName:           profile.LastName,
		TotalExperience:    profile.TotalExperience,
		ContactInformation: string(profile.ContactInformation),
		GoogleDriveLink:    profile.GoogleDriveLink,
		Status:             generated.ResourceStatus(profile.Status),
		VendorID:           profile.VendorID.String(), // Keep VendorID
		Vendor:             vendor,                    // Correctly set vendor
		ResourceSkills:     resourceSkillsGraphQL,
		PastProjects:       pastProjects,
	}, nil
}

// GetVendors is the resolver for the getVendors field.
func (r *queryResolver) GetVendors(ctx context.Context, filter *generated.VendorFilter, pagination *generated.PaginationInput, sort *generated.VendorSortInput) (*generated.VendorPage, error) {
	log.Println("GetVendors called")

	var vendors []models.Vendor
	query := initializers.DB.Model(&models.Vendor{})

	// Preload related data.
	query = query.
		Preload("ContactList").
		Preload("Skills").
		Preload("PerformanceRatings")
	//Preload("Resources") // Not preloading

	// --- Apply Filters ---
	if filter != nil {
		if filter.CompanyName != nil && *filter.CompanyName != "" {
			query = query.Where("vendors.company_name ILIKE ?", "%"+*filter.CompanyName+"%")
		}
		if filter.Status != nil {
			query = query.Where("vendors.status = ?", filter.Status)
		}
		if filter.PaymentTerms != nil {
			query = query.Where("vendors.payment_terms = ?", filter.PaymentTerms)
		}
		if filter.Search != nil && *filter.Search != "" {
			search := "%" + *filter.Search + "%"
			query = query.Where("vendors.company_name ILIKE ? OR vendors.notes ILIKE ?", search, search)
		}
		if filter.SkillIDs != nil && len(filter.SkillIDs) > 0 {
			query = query.Joins("JOIN vendor_skills ON vendor_skills.vendor_id = vendors.id").
				Where("vendor_skills.skill_id IN ?", filter.SkillIDs)
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.VendorSortFieldCreatedAt:
			query = query.Order("vendors.created_at " + order)
		case generated.VendorSortFieldUpdatedAt:
			query = query.Order("vendors.updated_at " + order)
		case generated.VendorSortFieldCompanyName:
			query = query.Order("vendors.company_name " + order)
		case generated.VendorSortFieldStatus:
			query = query.Order("vendors.status " + order)
		default:
			query = query.Order("vendors.created_at DESC")
		}
	} else {
		query = query.Order("vendors.created_at DESC")
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount)

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&vendors).Error; err != nil {
		log.Printf("Error fetching vendors: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch vendors")
	}

	// Map to GraphQL response type
	var result []*generated.Vendor
	for _, vendor := range vendors {
		// Map ContactList
		var contacts []*generated.Contact
		for _, contact := range vendor.ContactList {
			contacts = append(contacts, &generated.Contact{
				ContactID:   contact.ID.String(),
				CreatedAt:   contact.CreatedAt.Format(time.RFC3339),
				UpdatedAt:   contact.UpdatedAt.Format(time.RFC3339),
				VendorID:    contact.VendorID.String(),
				Name:        contact.Name,
				Email:       &contact.Email,       // Correct
				PhoneNumber: &contact.PhoneNumber, // Correct
			})
		}

		// Map Skills
		var skills []*generated.Skill
		for _, skill := range vendor.Skills {
			skills = append(skills, &generated.Skill{
				SkillID:     skill.ID.String(),
				Name:        skill.Name,
				Description: *skill.Description, // Dereference the pointer
				Skilltype:   generated.SkillType(skill.SkillType),
			})
		}

		// Map PerformanceRatings
		var performanceRatings []*generated.PerformanceRating
		for _, rating := range vendor.PerformanceRatings {
			performanceRatings = append(performanceRatings, &generated.PerformanceRating{
				PerformanceRatingsID: rating.ID.String(),
				CreatedAt:            rating.CreatedAt.Format(time.RFC3339),
				UpdatedAt:            rating.UpdatedAt.Format(time.RFC3339),
				VendorID:             rating.VendorID.String(),
				Rating:               int32(rating.Rating),
				Review:               rating.Review, // Corrected: Already a pointer
			})
		}

		// Map Resources (separate query)
		var resources []*generated.ResourceProfile
		var resourceModels []models.ResourceProfile
		if err := initializers.DB.
			Preload("ResourceSkills").
			Preload("ResourceSkills.Skill").
			Preload("PastProjects").
			Find(&resourceModels, "vendor_id = ?", vendor.ID).Error; err == nil {
			for _, resource := range resourceModels {
				resourceSkillsGraphQL := utils.ConvertResourceSkills(resource.ResourceSkills)

				var pastProjects []*generated.PastProject
				for _, project := range resource.PastProjects {
					pastProjects = append(pastProjects, &generated.PastProject{
						PastProjectID:     project.ID.String(),
						CreatedAt:         project.CreatedAt.Format(time.RFC3339),
						UpdatedAt:         project.UpdatedAt.Format(time.RFC3339),
						ResourceProfileID: project.ResourceProfileID.String(),
						ProjectName:       project.ProjectName,
						Description:       &project.Description, // Correct
					})
				}
				resources = append(resources, &generated.ResourceProfile{
					ResourceProfileID:  resource.ID.String(),
					Type:               generated.ResourceType(resource.Type),
					FirstName:          resource.FirstName,
					LastName:           resource.LastName,
					TotalExperience:    resource.TotalExperience,
					ContactInformation: string(resource.ContactInformation),
					GoogleDriveLink:    resource.GoogleDriveLink,
					Status:             generated.ResourceStatus(resource.Status),
					VendorID:           resource.VendorID.String(),
					ResourceSkills:     resourceSkillsGraphQL,
					PastProjects:       pastProjects,
				})
			}
		}

		result = append(result, &generated.Vendor{
			VendorID:           vendor.ID.String(),
			CreatedAt:          vendor.CreatedAt.Format(time.RFC3339),
			UpdatedAt:          vendor.UpdatedAt.Format(time.RFC3339),
			CompanyName:        vendor.CompanyName,
			Status:             generated.VendorStatus(vendor.Status),
			PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
			Address:            vendor.Address,
			GstOrVatDetails:    vendor.GstOrVatDetails,
			Notes:              vendor.Notes,
			ContactList:        contacts,
			Skills:             skills,
			PerformanceRatings: performanceRatings,
			Resources:          resources,
		})
	}

	return &generated.VendorPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetVendor is the resolver for the getVendor field.
func (r *queryResolver) GetVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	log.Println("GetVendor called")

	var vendor models.Vendor

	// Validate UUID
	if _, err := uuid.Parse(vendorID); err != nil {
		return nil, fmt.Errorf("invalid vendor ID")
	}

	// Preload associations
	if err := initializers.DB.
		Preload("ContactList").
		Preload("Skills").
		Preload("PerformanceRatings").
		//Preload("Resources"). // Not preloading here
		First(&vendor, "id = ?", vendorID).Error; err != nil {
		log.Printf("Error fetching vendor: %v", err)
		return nil, fmt.Errorf("vendor not found")
	}

	// Map ContactList
	var contacts []*generated.Contact
	for _, contact := range vendor.ContactList {
		contacts = append(contacts, &generated.Contact{
			ContactID:   contact.ID.String(),
			CreatedAt:   contact.CreatedAt.Format(time.RFC3339),
			UpdatedAt:   contact.UpdatedAt.Format(time.RFC3339),
			VendorID:    contact.VendorID.String(),
			Name:        contact.Name,
			Email:       &contact.Email,       // CORRECTED: Use pointer
			PhoneNumber: &contact.PhoneNumber, // CORRECTED: Use pointer
		})
	}

	// Map Skills
	var skills []*generated.Skill
	for _, skill := range vendor.Skills {
		skills = append(skills, &generated.Skill{
			SkillID:     skill.ID.String(),
			Name:        skill.Name,
			Description: *skill.Description, // Dereference the pointer
			Skilltype:   generated.SkillType(skill.SkillType),
		})
	}

	// Map PerformanceRatings
	var performanceRatings []*generated.PerformanceRating
	for _, rating := range vendor.PerformanceRatings {
		performanceRatings = append(performanceRatings, &generated.PerformanceRating{
			PerformanceRatingsID: rating.ID.String(),
			CreatedAt:            rating.CreatedAt.Format(time.RFC3339),
			UpdatedAt:            rating.UpdatedAt.Format(time.RFC3339),
			VendorID:             rating.VendorID.String(),
			Rating:               int32(rating.Rating),
			Review:               rating.Review, // Corrected: Already a pointer
		})
	}

	// Map Resources (separate query)
	var resources []*generated.ResourceProfile
	var resourceModels []models.ResourceProfile
	if err := initializers.DB.
		Preload("ResourceSkills").
		Preload("ResourceSkills.Skill").
		Preload("PastProjects").
		Find(&resourceModels, "vendor_id = ?", vendor.ID).Error; err == nil {
		for _, resource := range resourceModels {
			resourceSkillsGraphQL := utils.ConvertResourceSkills(resource.ResourceSkills)
			var pastProjects []*generated.PastProject
			for _, project := range resource.PastProjects {
				pastProjects = append(pastProjects, &generated.PastProject{
					PastProjectID:     project.ID.String(),
					CreatedAt:         project.CreatedAt.Format(time.RFC3339), // Standard format
					UpdatedAt:         project.UpdatedAt.Format(time.RFC3339),
					ResourceProfileID: project.ResourceProfileID.String(),
					ProjectName:       project.ProjectName,
					Description:       &project.Description, // Correct
				})
			}

			resources = append(resources, &generated.ResourceProfile{
				ResourceProfileID:  resource.ID.String(),
				Type:               generated.ResourceType(resource.Type),
				FirstName:          resource.FirstName,
				LastName:           resource.LastName,
				TotalExperience:    resource.TotalExperience,
				ContactInformation: string(resource.ContactInformation),
				GoogleDriveLink:    resource.GoogleDriveLink,
				Status:             generated.ResourceStatus(resource.Status),
				VendorID:           resource.VendorID.String(),
				ResourceSkills:     resourceSkillsGraphQL,
				PastProjects:       pastProjects,
			})
		}
	}

	return &generated.Vendor{
		VendorID:           vendor.ID.String(),
		CreatedAt:          vendor.CreatedAt.Format(time.RFC3339),
		UpdatedAt:          vendor.UpdatedAt.Format(time.RFC3339),
		CompanyName:        vendor.CompanyName,
		Status:             generated.VendorStatus(vendor.Status),
		PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
		Address:            vendor.Address,
		GstOrVatDetails:    vendor.GstOrVatDetails,
		Notes:              vendor.Notes,
		ContactList:        contacts,
		Skills:             skills,
		PerformanceRatings: performanceRatings,
		Resources:          resources,
	}, nil
}

// GetVendors is the resolver for the getVendors field.
// func (r *queryResolver) GetVendors(ctx context.Context, filter *generated.VendorFilter, pagination *generated.PaginationInput, sort *generated.VendorSortInput) (*generated.VendorPage, error) {
// 	// panic(fmt.Errorf("not implemented: GetVendors - getVendors"))
// 	var vendors []models.Vendor
// 	var totalCount int64

// 	db := initializers.DB.Model(&models.Vendor{})

// 	// Apply filtering
// 	if filter != nil {
// 		if filter.CompanyName != nil {
// 			db = db.Where("company_name ILIKE ?", "%"+*filter.CompanyName+"%")
// 		}
// 		if filter.Status != nil {
// 			db = db.Where("status = ?", *filter.Status)
// 		}
// 		if filter.PaymentTerms != nil {
// 			db = db.Where("payment_terms = ?", *filter.PaymentTerms)
// 		}
// 		if filter.Search != nil {
// 			searchPattern := "%" + *filter.Search + "%"
// 			db = db.Where("company_name ILIKE ? OR address ILIKE ?", searchPattern, searchPattern)
// 		}
// 		if len(filter.SkillIDs) > 0 {
// 			db = db.Joins("JOIN vendor_skills ON vendor_skills.vendor_id = vendors.id").
// 				Where("vendor_skills.skill_id IN ?", filter.SkillIDs)
// 		}
// 	}

// 	// Apply sorting
// 	if sort != nil {
// 		var sortOrder string
// 		if sort.Order == generated.SortOrderAsc {
// 			sortOrder = "asc"
// 		} else {
// 			sortOrder = "desc"
// 		}

// 		switch sort.Field {
// 		case generated.VendorSortFieldCreatedAt:
// 			db = db.Order("created_at " + sortOrder)
// 		case generated.VendorSortFieldUpdatedAt:
// 			db = db.Order("updated_at " + sortOrder)
// 		case generated.VendorSortFieldCompanyName:
// 			db = db.Order("company_name " + sortOrder)
// 		case generated.VendorSortFieldStatus:
// 			db = db.Order("status " + sortOrder)
// 		default:
// 			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
// 		}
// 	} else {
// 		//default sorting
// 		db = db.Order("created_at desc")
// 	}

// 	// Count total records before applying limit/offset for pagination
// 	db.Count(&totalCount)

// 	// Apply pagination
// 	if pagination != nil {
// 		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
// 	}

// 	// Execute the query
// 	if err := db.Preload("Skills").Find(&vendors).Error; err != nil {
// 		return nil, fmt.Errorf("failed to retrieve vendors: %w", err)
// 	}

// 	// Convert to generated type
// 	generatedVendors := make([]*generated.Vendor, len(vendors))
// 	for i, vendor := range vendors {
// 		//convert skills
// 		var generatedSkills []*generated.Skill
// 		//convert contact list
// 		var generatedContactList []*generated.Contact
// 		//convert performance ratings
// 		var generatedPerformanceRatings []*generated.PerformanceRating
// 		//convert resources
// 		var generatedResources []*generated.ResourceProfile

// 		generatedVendors[i] = &generated.Vendor{
// 			// ID:                 vendor.ID.String(),
// 			CompanyName:        vendor.CompanyName,
// 			Status:             generated.VendorStatus(vendor.Status),
// 			PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
// 			Address:            vendor.Address,
// 			GstOrVatDetails:    vendor.GstOrVatDetails,
// 			Notes:              vendor.Notes,
// 			Skills:             generatedSkills,
// 			ContactList:        generatedContactList,
// 			PerformanceRatings: generatedPerformanceRatings,
// 			Resources:          generatedResources,
// 		}
// 	}

// 	return &generated.VendorPage{
// 		Items:      generatedVendors,
// 		TotalCount: int32(totalCount),
// 	}, nil
// }

// // GetVendor is the resolver for the getVendor field.
// func (r *queryResolver) GetVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
// 	// panic(fmt.Errorf("not implemented: GetVendor - getVendor"))
// 	parsedVendorID, err := uuid.Parse(vendorID)
// 	if err != nil {
// 		return nil, fmt.Errorf("invalid vendor ID: %w", err)
// 	}

// 	var vendor models.Vendor
// 	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
// 		if errors.Is(err, gorm.ErrRecordNotFound) {
// 			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
// 		}
// 		return nil, fmt.Errorf("error retrieving vendor: %w", err)
// 	}

// 	//convert skills
// 	var generatedSkills []*generated.Skill
// 	//convert contact list
// 	var generatedContactList []*generated.Contact
// 	//convert performance ratings
// 	var generatedPerformanceRatings []*generated.PerformanceRating
// 	//convert resources
// 	var generatedResources []*generated.ResourceProfile
// 	return &generated.Vendor{
// 		// ID:                 vendor.ID.String(),
// 		CompanyName:        vendor.CompanyName,
// 		Status:             generated.VendorStatus(vendor.Status),
// 		PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
// 		Address:            vendor.Address,
// 		GstOrVatDetails:    vendor.GstOrVatDetails,
// 		Notes:              vendor.Notes,
// 		Skills:             generatedSkills,
// 		ContactList:        generatedContactList,
// 		PerformanceRatings: generatedPerformanceRatings,
// 		Resources:          generatedResources,
// 	}, nil
// }

// GetTasks is the resolver for the getTasks field.
func (r *queryResolver) GetTasks(ctx context.Context, filter *generated.TaskFilter, pagination *generated.PaginationInput, sort *generated.TaskSortInput) (*generated.TaskPage, error) {
	// panic(fmt.Errorf("not implemented: GetTasks - getTasks"))
	var tasks []models.Task
	query := initializers.DB.Model(&models.Task{})

	// Filtering
	if filter != nil {
		if filter.UserID != nil {
			query = query.Where("user_id = ?", *filter.UserID)
		}
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
		if filter.Priority != nil {
			query = query.Where("priority = ?", *filter.Priority)
		}
		// Remove the due date filter as it does not exist in the TaskFilter type
	}

	// Sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.TaskSortFieldTitle:
			query = query.Order("title " + sortOrder)
		case generated.TaskSortFieldStatus:
			query = query.Order("status " + sortOrder)
		case generated.TaskSortFieldPriority:
			query = query.Order("priority " + sortOrder)
		case generated.TaskSortFieldDueDate:
			query = query.Order("due_date " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		query = query.Order("created_at desc")
	}

	// Pagination
	var totalCount int64
	query.Count(&totalCount)
	if pagination != nil {
		query = query.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&tasks).Error; err != nil {
		return nil, err
	}

	return &generated.TaskPage{
		Items: func() []*generated.Task {
			var gqlTasks []*generated.Task
			for _, task := range tasks {
				gqlTasks = append(gqlTasks, &generated.Task{
					TaskID:   task.ID.String(),
					Title:    task.Title,
					Status:   generated.TaskStatus(task.Status),
					Priority: generated.TaskPriority(task.Priority),
					DueDate:  task.DueDate.Format(time.RFC3339),
				})
			}
			return gqlTasks
		}(),
		TotalCount: int32(totalCount),
	}, nil
}

// GetTasksByUser is the resolver for the getTasksByUser field.
func (r *queryResolver) GetTasksByUser(ctx context.Context, filter *generated.TaskFilter, pagination *generated.PaginationInput, sort *generated.TaskSortInput) (*generated.TaskPage, error) {
	// panic(fmt.Errorf("not implemented: GetTasksByUser - getTasksByUser"))
	var tasks []models.Task

	jwtClaims, ok := auth.GetUserFromJWT(ctx)
	if !ok {
		return nil, fmt.Errorf("no user in jwt returned")
	}

	userID, ok := jwtClaims["user_id"].(string)
	if !ok {
		fmt.Println("UserID not found in token")
	}

	expFloat, ok := jwtClaims["exp"].(float64) // JWT stores numbers as float64
	if !ok {
		fmt.Println("Exp not found in token")
	} else {
		fmt.Println("Exp:", time.Unix(int64(expFloat), 0)) // Convert to human-readable format
	}

	query := initializers.DB.Model(&models.Task{}).Where("user_id = ?", userID)

	// Filtering
	if filter != nil {
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
		if filter.Priority != nil {
			query = query.Where("priority = ?", *filter.Priority)
		}
		// Remove the due date filter as it does not exist in the TaskFilter type
	}

	// Sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.TaskSortFieldTitle:
			query = query.Order("title " + sortOrder)
		case generated.TaskSortFieldStatus:
			query = query.Order("status " + sortOrder)
		case generated.TaskSortFieldPriority:
			query = query.Order("priority " + sortOrder)
		case generated.TaskSortFieldDueDate:
			query = query.Order("due_date " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		query = query.Order("created_at desc")
	}

	// Pagination
	var totalCount int64
	query.Count(&totalCount)
	if pagination != nil {
		query = query.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute query
	if err := query.Find(&tasks).Error; err != nil {
		return nil, err
	}

	return &generated.TaskPage{
		Items: func() []*generated.Task {
			var gqlTasks []*generated.Task
			for _, task := range tasks {
				gqlTasks = append(gqlTasks, &generated.Task{
					TaskID:   task.ID.String(),
					Title:    task.Title,
					Status:   generated.TaskStatus(task.Status),
					Priority: generated.TaskPriority(task.Priority),
					DueDate: func() string {
						if task.DueDate != nil {
							formatted := task.DueDate.Format(time.RFC3339)
							return formatted
						}
						return ""
					}(),
				})
			}
			return gqlTasks
		}(),
		TotalCount: int32(totalCount),
	}, nil
}

// GetTask is the resolver for the getTask field.
func (r *queryResolver) GetTask(ctx context.Context, taskID string) (*generated.Task, error) {
	// panic(fmt.Errorf("not implemented: GetTask - getTask"))
	var task models.Task

	// Convert taskID to UUID
	taskUUID, err := uuid.Parse(taskID)
	if err != nil {
		return nil, fmt.Errorf("invalid task ID format: %w", err)
	}

	// Fetch task from the database
	if err := initializers.DB.Preload("User").Where("id = ?", taskUUID).First(&task).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("task not found")
		}
		return nil, err
	}

	// Convert to GraphQL type
	return &generated.Task{
		TaskID:      task.ID.String(),
		User:        &generated.User{UserID: task.User.ID.String(), Name: task.User.Name, Email: task.User.Email}, // Adjust as needed
		Title:       task.Title,
		Description: &task.Description,
		Status:      generated.TaskStatus(task.Status),
		Priority:    generated.TaskPriority(task.Priority),
		DueDate:     task.DueDate.Format(time.RFC3339),
	}, nil
}

// GetCaseStudies is the resolver for the getCaseStudies field.
func (r *queryResolver) GetCaseStudies(ctx context.Context, filter *generated.CaseStudyFilter, pagination *generated.PaginationInput, sort *generated.CaseStudySortInput) ([]*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: GetCaseStudies - getCaseStudies"))
	var caseStudies []*models.CaseStudy
	db := initializers.DB

	// Apply Filters
	if filter != nil {
		if filter.ProjectName != nil {
			db = db.Where("project_name ILIKE ?", "%"+*filter.ProjectName+"%")
		}
		if filter.ClientName != nil {
			db = db.Where("client_name ILIKE ?", "%"+*filter.ClientName+"%")
		}
		if filter.TechStack != nil {
			db = db.Where("tech_stack ILIKE ?", "%"+*filter.TechStack+"%")
		}
		if filter.IndustryTarget != nil {
			db = db.Where("industry_target ILIKE ?", "%"+*filter.IndustryTarget+"%")
		}
		if filter.Tags != nil {
			db = db.Where("tags ILIKE ?", "%"+*filter.Tags+"%")
		}
		// Apply Search across multiple fields
		if filter.Search != nil {
			searchQuery := "%" + *filter.Search + "%"
			db = db.Where("project_name ILIKE ? OR client_name ILIKE ? OR tech_stack ILIKE ? OR industry_target ILIKE ? OR tags ILIKE ?",
				searchQuery, searchQuery, searchQuery, searchQuery, searchQuery)
		}
	}

	// Apply Sorting
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.CaseStudySortFieldCreatedAt:
			db = db.Order("created_at " + order)
		case generated.CaseStudySortFieldUpdatedAt:
			db = db.Order("updated_at " + order)
		case generated.CaseStudySortFieldTechStack:
			db = db.Order("tech_stack " + order)
		case generated.CaseStudySortFieldIndustryTarget:
			db = db.Order("industry_target " + order)
		}
	}

	// Apply Pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Fetch case studies
	if err := db.Find(&caseStudies).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve case studies: %v", err)
	}

	// Convert to GraphQL type
	var gqlCaseStudies []*generated.CaseStudy
	for _, cs := range caseStudies {
		gqlCaseStudies = append(gqlCaseStudies, &generated.CaseStudy{
			CaseStudyID:     cs.ID.String(),
			ProjectName:     cs.ProjectName,
			ClientName:      cs.ClientName,
			TechStack:       cs.TechStack,
			ProjectDuration: cs.ProjectDuration,
			KeyOutcomes:     cs.KeyOutcomes,
			IndustryTarget:  cs.IndustryTarget,
			Tags:            cs.Tags,
			Document:        cs.Document,
		})
	}

	return gqlCaseStudies, nil
}

// GetCaseStudy is the resolver for the getCaseStudy field.
func (r *queryResolver) GetCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	var caseStudy models.CaseStudy
	// Fetch case study by ID from the database
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, fmt.Errorf("case study not found: %v", err)
	}
	// Convert model to GraphQL type
	return &generated.CaseStudy{
		CaseStudyID:     caseStudy.ID.String(), // Ensure correct ID format
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// GetSkills is the resolver for the getSkills field.
func (r *queryResolver) GetSkills(ctx context.Context, filter *generated.SkillFilter, pagination *generated.PaginationInput, sort *generated.SkillSortInput) (*generated.SkillPage, error) {
	panic(fmt.Errorf("not implemented: GetSkills - getSkills"))
}

// GetSkill is the resolver for the getSkill field.
func (r *queryResolver) GetSkill(ctx context.Context, skillID string) (*generated.Skill, error) {
	panic(fmt.Errorf("not implemented: GetSkill - getSkill"))
}

// GetMadeBy is the resolver for the getMadeBy field.
func (r *queryResolver) GetMadeBy(ctx context.Context) ([]*generated.MadeBy, error) {
	return []*generated.MadeBy{
		{
			ID:          "faeizmn",
			Name:        "Faiz Mansuri",
			Role:        "Backend Lead",
			Description: "Lead Backend Developer, Designed and Developed the backend architecture for the application and managed the project resources effectively.",
			LinkedInURL: "www.linkedin.com/in/faeizmn",
		},
		{
			ID:          "besIT",
			Name:        "Basit Saiyed",
			Role:        "Backend Developer",
			Description: "Backend Developer, Google Calender integration",
			LinkedInURL: "linkedin.com/in/basit-saiyed",
		},
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
